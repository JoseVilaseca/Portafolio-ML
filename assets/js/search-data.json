{
  
    
        "post0": {
            "title": "Introducción al modelo crispdm",
            "content": "LinkedIn GitHub . Índice . Introducción | Crisp DM | Entendimiento del Negocio | Entendimiento de los Datos | Preparación de los Datos | Modelado | Caso de estudio 1 | Artículos publicados y presentaciones realizadas | Introducción . El desarrollo de soluciones que utilicen inteligencia artificial debe ser holistico en el sentido que todas las partes/períodos del desarrollo son sumamente importantes y están muy interrelacionadas entre sí. Por esto, existe un estándar llamado CRISP DM, en el cual se basará este portafolio para explicar qué se debe hacer en cada paso del desarrollo de soluciones, con los puntos clave en cada uno de ellos. . Crisp DM . El proceso CRISP-DM (Cross-Industry Standard Process for Data Mining) describe las fases principales de un proyecto de minería/ciencia de datos, incluyendo la relación que existe entre cada etapa. . . A continuación se explicará qué se debe considerar en cada etapa del proceso CRISP-DM. . Entendimiento del Negocio . El entendimiento del negocio y de la industria para la cual se realizará un proyecto que involucre aprendizaje automático es sumamente importante. Hay ciertas industrias que priorizan el entendimiento de los modelos antes que la performance per se que estos tengan. Por ejemplo, para industrias en las que el resultado de una predicción puede afectar positiva o negativamente la vida de una persona, es muy importante que se pueda explicar por qué se tomó esa decisión, por lo que algunos algoritmos complejos (cajas negras, ej. redes neuronales profundas) quedan descartados para el modelado. . También, la naturaleza de la solución pondrá restricciones sobre las distintas alternativas de una solución. Por ejemplo, un sistema de clasificación de imágenes/detección de objetos en tiempo real, deberá poder generar varias predicciones por segundo, lo que limita tanto el lugar en donde estará desplegado el modelo (probáblemente en un sistema embebido o en el edge) y deberá tener una potencia computacional alta para poder cumplir con las restricciones. Las librerías también deberán estar específicamente optimizadas para poder correr en sistemas que no posean grandes cantidades de memoria y ser sumamente eficientes en las funcionalidades que proveen (TF Lite es un buen ejemplo de esto). . Por otro lado, si estamos hablando de soluciones en las que el modelo se entrena una vez por día y se tiene un conjunto muy grande de datos, se deberán priorizar los algoritmos que puedan proveer una performance decente, pero principalmente que posean un tiempo de entrenamiento bajo, para cumplir con las restricciones temporales. . Entendimiento de los Datos . Luego de entender el negocio y las posibles aristas por las que se podrá proseguir en un proyecto, el siguiente paso es entender los datos. El entendimiento de los datos o análisis exploratorio de los datos, es nuestro primer acercamiento a ellos. En él, se intentarán descubrir los patrones invisibles a primera vista que existen en los datos. . En este paso, deberemos estudiar los tipos de los atributos, ver qué tipo de solución requiere el problema a resolver, ¿es de clasificación, regresión o clustering? También, se deben analizar las distribuciones de todos los atributos. Por último, se deben generar hipótesis sobre relaciones en los datos que luego deberán ser probadas en el paso del modelado. . . . Preparación de los Datos . Nuestros modelos son tan buenos como los son nuestros datos. Por esto es muy importante hacer un preprocesamiento a los mismos acorde al algoritmo de aprendizaje que vayamos a utilizar para modelar el problema. Se deberá contar con una cantidad de datos suficiente y representativa para que los modelos generados puedan abstraer los conceptos subyacentes que existen en el conjunto de datos. . Debido a lo antes mencionado, hay varias aristas a recorrer en la etapa de la preparación de los datos. . Normalizado y Estandarización . Existe una gran cantidad de algoritmos que obtienen mejores resultados cuando rangos de los predictores estén normalizados o estandarizados. Existen muchas formas de normalizar los datos pero a lo largo del portafolio, utilizaré las 2 más comunes mencionadas a continuación . Normalización Min-Max . Este tipo de normalización utiliza los valores mínimo y máximo del conjunto y utiliza la siguiente transformación para obtener los nuevos valores de nuestro predictor. Los posibles valores pertenecen al rango [0,1]. . . #### Estandarización o Transformación Z Dicha técnica de normalizado refiere a la utilización de la media y de la desviación estándar de un atributo para realizar la siguiente transformación. La distribución resultante tendrá media 0 y desviación estandar 1. . . Manejo de valores faltantes o nulos . En un mundo ideal, los datasets no poseerían valores faltantes pero la realidad está bastante alejada de eso. Tanto en datasets utilizados mundialmente (por ejemplo Titanic) como también en datasets de empresas que quieren incorporar ciencia de datos a sus procesos, la presencia de valores nulos es algo común. . En primera instancia, se debe analizar qué significan estos valores nulos, porque pueden tener distintos significados dependiendo del contexto. Uno de los posibles significados de un valor nulo es que no se cargó el dato o no se conoce el valor exacto, pero este dato probáblemente se encuentra en el rango de valores de la distribución del atributo al que pertenece (MAR). . Otro significado diferente es que un dato no tenga sentido que exista y debido a esto, se coloca el valor nulo en el ejemplo. Por ejemplo, en una encuesta en la que se pregunta por salario a personas, no tiene sentido que una persona que no posee un empleo actualmente cargue un valor numérico en el atributo salario. . Luego de conocer el significado de los valores nulos, hay que elegir una estrategia para tratarlos. . Elección de algoritmos que permitan valores nulos . Se pueden utilizar algoritmos como Naive Bayes o KNN. . Imputación de valores con media, mediana y moda . Para atributos numéricos, cuando la distribución de este es normal, se suele imputar con la media de la distribución. Cuando la distribución está sesgada, imputar con la mediana es una mejor elección. . Para atributos categóricos, imputar con la moda es una buena forma de deshacernos de los valores nulos. . Utilización de un modelo para predecir valores nulos. . Una estrategia más compleja, pero generalmente más aproximada es utilizar un modelo para predecir qué valor debería ocupar el lugar del valor nulo dependiendo de los otros atributos del ejemplo. . Outliers . Los outliers son valores que se alejan significativamente del resto de la muestra. Dependiendo de nuestra aplicación en particular, estos casos deberán ser removidos o tratados con especial cuidado porque pueden llegar a ser claves para detectar algún fenómeno que estemos tratando de predecir (por ejemplo detección de fraude). . . Muestreo para dasets desbalanceados . Cuando se posee un dataset significativamente desbalanceado, los ejemplos de una de las clases tienen una cardinalidad significativamente menor que la cardinalidad de los ejemplos de la otra clase (para problemas de clasificación binaria). La relación entre ellas puede ser 1:50, 1:100 o incluso más diferencia. . Este sesgo puede influir en el aprendizaje de muchos algoritmos de machine learning, lo que suele resultar en un sobreajuste que predice siempre la clase más numerosa, o tiene una performance baja para predecir ejemplos de la clase minoritaria, que suelen ser los casos más importantes y los que nos interesa reconocer. . Dos estrategias posibles para atacar estos casos es aplicar submuestreo (undersampling) o sobremuestreo (oversampling). En el submuestreo se reduce la cantidad de ejemplos de la clase más numerosa de forma aleatoria y en el sobremuestreo se generan nuevos ejemplos de la clase menos numerosa a partir de los ejemplos existentes. Una de las librerías más utilizadas que ataca este problema se llama imblearn. . Transformaciones para atributos con distribución sesgada . Para distribuciones fuertemente sesgadas (skewed), aplicar transformaciones a la misma generalmente mejora la performance de los modelos entrenados con dichos datos. Dos transformaciones recomendadas son la función logarítmica y la transformación Box-Cox. . . . Selección de atributos y feature engineering (Utilizado y explicado en casos de estudio y post) . Modelado . La etapa de modelado refiere a la creación de modelos a partir de datos. Estos modelos aprenderán de relaciones entre los datos con los que se entrenen y podrán hacer predicciones sobre datos no vistos. . A continuación se presentarán 2 grandes categorías de algoritmos de Machine Learning: los algoritmos lineales y los no lineales. . Algoritmos Lineales . Los algoritmos lineales asumen una relación lineal entre los predictores y la variable objetivo. Son algoritmos simples que tienen un gran potencial para modelar relaciones lineales. El poseer distribuciones gausianas en los atributos ayuda a estos algoritmos a obtener mejores resultados. . Regresión Lineal . A pesar de la simplicidad del algortitmo de regresión lineal, este algoritmo sigue siendo muy utilizado por su capacidad de modelar relaciones lineales. A diferencia de algoritmos más complejos, este posee numerosas ventajas como lo son: . -Tiempo de entrenamiento bajo . -Posibilidad de explicar por qué se predice un valor para un ejemplo no visto . -Tiempo de predicción/inferencia bajo . Regresión Logística . Para problemas de clasificación binarios, la regresión logística es un algoritmo simple y performante. Este utiliza la función logística (o función sigmoide) que transforma una combinacion lineal de variables a un rango entre 0 y 1. En este caso, el valor que tomará la función coincide con la probabilidad con la que el modelo puede afirmar que un ejemplo pertenece a la clase por defecto. . Utilizando esta probabilidad, podremos generar predicciones escogiendo un umbral (desde un aspecto probabilístico 0,5 sería el umbral correcto) y luego definiendo que un ejemplo pertenece a la clase primaria si su probabilidad es mayor a ese umbral y que pertenece a la clase secundaria en el caso contrario. . Análisis Discriminante Lineal . En el caso de problemas de clasificación multiclase, la opción lineal por defecto es el análisis discriminante lineal. Este algoritmo no posee ciertas desventajas que existen en la regresión logística como la limitación a problemas de 2 clases, su inestabilidad con clases bien separadas y su inestabilidad cuando se tienen pocos ejemplos. . Algoritmos no lineales . Estos algoritmos no asumen una relación de algún tipo específico como lo hacen los algoritmos lineales. Suelen tener menos sesgo (bias) dado que no asumen una relación específica entre los predictores y la variable objetivo, pero una mayor varianza (variance) que los algoritmos lineales. . Árboles de Decisión . Los árboles de decisión son algoritmos que derivan de la rama de informática. Utilizando la estructura de un árbol, cada nodo posee una condición asociada a una única variable de entrada, y dependiendo del valor, el árbol decidirá por qué hijo se deberá proceder para que se pueda aplicar una predicción. Al llegar a un nodo hoja, se aplica la predicción. . Para el entrenamiento de los mismos se utilizan conceptos como la ganancia de información o el índice de gini para determinar cuáles son las mejores particiones de los datos tal que exista una mayor ganancia de información o mayor separación de las clases. . Este tipo de algoritmo requiere que se aplique una optimización de hiperparámetros para reducir el sobreajuste del modelo al set de entrenamiento. Existen múltiples parámetros que ayudan a que el ajuste sea el correcto como por ejemplo limitar la altura del arbol, escoger un mínimo de ejemplos para cada nodo hoja, etc. . Máquinas de Soporte Vectorial . Las máquinas de soporte vectorial son un tipo de algoritmo de machine learning relativamente moderno (las primeras implementeciones se desarrollaron en los años 90). Este es un algoritmo para problemas de clasificación binaria (en su implementación básica, pues existen extensiones que amplian el algoritmo para problemas multiclase). . El propósito de este tipo de algoritmo es utilizar vectores de soporte (puntos de ambas clases que actúen como límites de su clase), un tipo de kernel (lineal, polinómico, radial, etc) y una constante C (definirá la flexibilidad con la que permitiremos violaciones respecto al márgen o frontera que se utilizará para la clasificación) para generar una función n-dimensional que separe a ambas clases de la mejor manera posible. . Artículos publicados y presentaciones realizadas . Despliega tu primer modelo de reconocimiento de imágenes en la nube GitHub . Watson de la A a la Z - Visual Recognition y Natural Language Classifier .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/12/02/Introducci%C3%B3n-al-modelo-CrispDm.html",
            "relUrl": "/2021/12/02/Introducci%C3%B3n-al-modelo-CrispDm.html",
            "date": " • Dec 2, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Caso De Estudio 3 Enfermedad Cardíaca",
            "content": "Caso de estudio 3 . Predicción de enfermedad de corazón . En la actualidad, las enfermedades cardíacas son la principal casusa de muerte a nivel mundial[1] . La enfermedad isquémica del corazón fue responsable del 16% de las muertes globales en el 2019. En los Estados Unidos, la principal causa de muerte es otra enfermedad cardíaca llamada enfermedad de la arteria coronaria[2]. . Además de esto, entre 3 a 5% de las admisiones a hospitales se deben a pacientes con insuficiencia cardíaca. Un 2% de los costos médicos de los países desarrollados son resultado de dicha condición.[3] . Debido a este problema mundial, una de las disciplinas en las que se aborda el tema con la intención de mitigar los riesgos y costos, mejorando así la calidad de vida de las personas es Machine Learning. Utilizando diferentes técnicas de aprendizaje automático, se puede estimar con cierto grado de confianza la presencia, el subtipo, y la severidad de una enfermedad cardíaca. Más aún, se pueden predecir eventos como desestabilizaciones, re-hospitalizaciones y mortalidad. . Descripción de los conjutos de datos utilizados . Los conjuntos de datos utilizados en este caso de estudio son 4 datasets distintos. Cada uno de estos contiene medidas de 76 atributos (los mismos atributos en cada dataset), pero los datasets provienen de diferentes instituciones médicas. Estas son: Cleveland Clinic Foundation, Hungarian Institute of Cardiology, Budapest, V.A. Medical Center, Long Beach, CA y University Hospital, Zurich, Switzerland. . Los datasets contienen entre 123 y 294 ejemplos cada uno. . Algunos de los atributos a destacar, utilizados en estudios previos son . 1) Age: edad en años del paciente. Posee una distribución gaussiana con media 53, y desvío 9. . 2) Sex: 1-Masculino 0-Femenino. Predominan los ejemplos masculinos por un gran margen (711 contra 188) . 3) Cp: Tipo de dolor en el pecho. Valores de 1 a 4. El valor 4 es el predominante (asintomatico, 485 ejemplos), mientras que el 1 es el más escaso con solo 45 ejemplos. Los valores 2 y 3 poseen entre 150 y 200 ejemplos. . 4) Trestbps: Presión sanguínea en reposo (medida en mm Hg al ingresar al hospital). Posee una distribución gaussiana. Tiene valores faltantes. . 5) Chol: colesterol en suero (en mg/dl). Distribución no se asemeja a una conocida. . 6) Fbs: nivel de azucar en ayuno &gt; 120 mg/dl (1 = verdadero; 0 = falso). 0 es mucho más prevalente en el dataset (674 vs 135) . 7) Restecg: electrocardiograma en reposo (0-Normal, 1-having ST-T wave abnormality, 2-showing probable or definite left ventricular hypertrophy by Estes’ criteria). 0 es el valor más prevalente, 1 y 2 tienen cardinalidades parecidas (177 y 182) . 8) Thalach: ritmo cardíaco máximo alcanzado. Se asemeja a una distribución normal con un leve sesgo hacia la izquierda. . 9) Exang: angina inducida por ejercicio (1-Si, 0-No). Existen 514 ejemplos para el valor 0 y 330 para el valor 1. . 10) Oldpeak: ST depression induced by exercise relative to rest. Distribución no se asemeja a una conocida. . 11) Slope: the slope of the peak exercise ST segment (1-upsloping, 2-flat, 3-downsloping). El caso más común es 2, seguido por 1 y el menos prevalente es el 3. . 12) Ca: number of major vessels (0-3) colored by flourosopy. Distribución sesgada hacia la derecha. A medida que se aumenta el número de vasos, los ejemplos disminuyen. . 13) Thal: 3 = normal; 6 = fixed defect; 7 = reversable defect. Posee 477 valores faltantes. Mayor prevalencia en 3 y 7 (alrededor de 180 ejemplos). . 14) Num: diagnosis of heart disease (angiographic disease status) (0- &lt; 50% diameter narrowing, 1- &gt; 50% diameter narrowing). Los posibles valores enteros van del 0 al 4. #0=404, #1=191, #2=130, #3=132, #4=42. 0 significa que el paciente no posee la condición y los valores de 1 a 4 indican la severidad de la misma . Los datos poseen atributos faltantes y están representados con el valor -9. . El dataset de Cleveland posee unas pocas filas corruptas por encoding al final del archivo. Las primeras 282 filas de las 293 no tienen problemas, por lo que esas serán las utilizadas en los siguientes pasos del caso de estudio. . Preparación previa de los datos . Antes de cargar los datasets en rapidminer, es necesario aplicarles una limpieza o transformación para tenerlos estructurados. El script utilizado se puede observar el el repositorio de github del portafolio. . Flujo Rapidminer . . Selección de atributos previa . Debido a la gran cantidad de valores faltantes en algunos atributos, decido descartar los que tengan más de 33% de valores faltantes. También descarto name e id. . Columnas descartadas: . Name, Id, ccf, pncaden, cigs, years, dm, famhist, smoke, thaltime, slope, rldv5, ca, restckm, exerckm, restef, restwm, exeref, exerwm, thal, thalsev, thalpul, earlobe, ramus, om2, cathef, junk. . Estrategias de imputación . Para los predictores con una mayor cantidad de valores nulos dentro de los que no fueron descartados y de tipo categóricos, decido elegir un valor definido que represente que ahí existe un valor nulo. Imputo con el valor -1. Luego, decido imputar los restantes predictores categóricos con su moda (estos tienen menos de 19 valores nulos que equivale aproximadamente a un 2% de los ejemplos). Además, estos poseen una cardinalidad extremadamente alta en su moda, por lo que esta imputación, con un grado de seguridad muy alto, representa el valor exacto que tendrían estos ejemplos. Por último, se decide imputar los últimos valores faltantes con la media, ya que la gran mayoría de estos poseen distribuciones gaussianas o uniformes y valores enteros o reales. Hay 3 predictores en los que hubiera escogido una estrategia de imputación utilizando la mediana por su distribución fuertemente sesgada hacia la derecha (predictores ridv5e, proto y met, véase la imagen a continuación). Se podría aplicar una transformación logarítmica a estos 3 predictores para obtener una distribución más parecida a una gaussiana. . (Distribuciones simil-gaussianas) . . (Distribuciones fuertemente sesgadas hacia la derecha) . . Para el modelado con KNN, se aplicará además una normalización a los datos, ya que este modelo requiere dicha normalización. . Una nota importante sobre la preparación previa de los datos es que la única estrategia que se realizará previo a los bloques anidados de cross validation es la estrategia de imputación con el valor conocido -1 que representa que el valor es uno no conocido. Esto no depende del set de datos elegido por un Split específico de entrenamiento/test, ya que este valor siempre será el mismo. . La historia es diferente cuando hablamos de la media, moda y la transformación específica que se aplica para normalizar. Estas transformaciones sí dependen de los datos que se eligen, por lo que normalizar o imputar con uno de estos valores antes de separar los conjuntos en entrenamiento y testeo contribuye con un fenómeno llamado contaminación accidental. Dicho fenómeno causa que las estimaciones de las métricas que realizamos para validar nuestros modelos no sean realistas, siendo más optimistas que el rendimiento verdadero que tendrá nuestro modelo. . Por los argumentos expuestos en el párrafo anterior, estas transformaciones se realizarán para los conjuntos de entrenamiento (por ejemplo, se toma la media y desviación estándar del conjunto de entrenamiento), y luego se transforma a los datos de testeo con los valores hallados para la transformación de los datos de entrenamiento. . En la imagen a continuación, se pueden observar los operadores dentro del proceso de CV externo. Se puede apreciar que la media y moda (no hay un bloque de normalización debido al algoritmo random forest) se calculan para el conjunto de entrenamiento, y previo a realizar nuestras predicciones con el modelo en el conjunto de testeo, se aplican las imputaciones deseadas en el bloque Apply Model (3). . 4- Algoritmos y modelos . En cuanto al algoritmo de aprendizaje para generar el modelo de predicción de enfermedades del corazón, claramente debemos considerar los algoritmos supervisados de clasificación. . Utilizando los estudios Citados por el paper “Heart Failure: Diagnosis, Severity Estimation and Prediction of Adverse Events Through Machine Learning Techniques”[3] , diversos grupos de investigadores utilizaron diferentes algoritmos de ML, por lo que elegir uno a priori sin probar una gran variedad de ellos sería un enfoque bastante ingenuo y sesgado en mi opinión. Debido a esto, utilizaré una variedad de algoritmos y elegiré el que mejor se adecúe al dataset elegido. . Como primer paso, propongo utilizar Naive bayes como benchmark inicial de performance. Este utilizará la corrección de Laplace para prevenir el error provocado por el caso en el que exista un valor en el set de test que no haya estado en el set de entrenamiento. Me parece pertinente remarcar que se utilizará sampling estratificado en el bloque de cross validation (siempre utilizaré este tipo de sampling, pero este es especialmente importante para Naive Bayes). Luego, consideraré una serie de algoritmos utilizados por los investigadores de los papers consultados. . Dentro de estos, se podría justificar no utilizar knn por un consumo alto de memoria debido a un dataset de entrenamiento grande, pero con los bajos costos de memoria de hoy en día, este no debería ser un impedimento para un conjunto de datos que pese un par de megas. El orden cuadrático para realizar predicciones (n*(n-1)/2) igualmente podría suponer un problema. Como nuestro dataset no es uno muy grande (no supera los 1000 ejemplos), no habría que descartar este algoritmo. Si utilizaramos otra herramienta como Python-scikitlearn, se debería aplicar one-hot encoding para los predictores categóricos, pero en rapidminer esto no es necesario, ya que se puede utilizar una mixed measure llamada mixed euclidean distance. Para los valores nominales, la distancia es 0 si ambos valores son iguales y 1 si son diferentes. Para valores numéricos, se utiliza la distancia euclídea. Por esto, para que todos los predictores tengan el mismo rango, se normaliza con la transformación min-max (de 0 a 1) . Luego de obtener las métricas para el modelo de KNN, utilizaré difentes tipos de ensambles inicialmente Random Forest y alguna variante de Boosted Trees como AdaBoost o GradientBoostedTrees (Rapidminer) debido a su alta performance para casos de la industria estudiada. Además, como otra justificación para utilizar estos métodos, no existe un requerimiento de que las predicciones tengan que ser extremadamente rápidas, por lo que la utilización de un modelo de Random Forest con miles de árboles no sería un problema. Como los boosted trees son muy susceptibles a outliers, se deberá analizar cuidadosamente la presencia de estos. . SVM es un algoritmo que no podrá ser utilizado para este caso en específico pues se poseen atributos categóricos, no soportados por este algoritmo. . Como este es mi último caso de estudio, decido utilizar toda la batería de conceptos aprendidos en el curso para generar modelos robustos con una validación correcta con la menor contaminación accidental posible. También, se tomarán en cuenta las distintas métricas que podemos obtener de cada modelo para hacer las comparaciones de los modelos obtenidos. . Todos los bloques de cross validation utilizados en la solución, usan la misma semilla y k=5 debido al altísimo costo computacional necesario para tanto entrenar los mejores modelos posibles (utilización de estrategias evolutivas para selección de atributos y para tuning de hiperparámetros) como aplicar una correcta validación de los mismos. Esta correcta validación implica bloques de cross validation anidados. . Naive Bayes . . . KNN . Se optimiza k (valores entre 1 y 100) . . . Random Forest . Se optimizan los hiperparámetros: . 1) subset_ratio entre 0.2 y 1. (Según [4] Se recomienda utilizar la raíz de la cantidad de predictores para problemas de clasificación) . 2) number_of_trees entre 500 y 3000. . . GradientBoostedTrees . Se optimizan los hiperparámetros: . 1) Number_of_trees: de 50 a 500 . 2) Learning_rate: de 0.05 a 1 . 3) Maximal_depth: de 1 a 10 . . . Conclusiones sobre los diferentes modelos . Como se puede ver en las matrices de confusión expuestas anteriormente, dos de los modelos quedan claramente descartados. Estos son KNN y Naive bayes. Su performance no está al nivel de los dos últimos modelos generados, y como lo que buscamos para este caso es maximizar la performance al máximo, no seguimos explorando la posibilidad de utilizar estos algoritmos. . En cambio, la performance de los ensembles escogidos es buena, significativamente mejor que la de los modelos anteriores. Pero eso nos lleva a la pregunta: ¿cuál de los 2 modelos escogemos como el mejor para este caso de estudio? . Normalmente, la métrica a la que se le da más importancia es al accuracy o exactitud. Si nos guiáramos por esa métrica, claramente escogeríamos el modelo entrenado utilizando Random Forest por su aumento de 2.56% en el accuracy promedio frente al otro modelo según la validación cruzada que se realizó. . No obstante, en este caso de estudio, no nos guiaremos por esa métrica absoluta, pues ese no es el punto más importante. Como en este caso un falso negativo (con negativo me refiero a no enfermedad) para la clase 0 (predecir que un paciente no posee la enfermedad cuando en realidad la tiene) es extremadamente costoso en cuanto a costos monetarios y la vida de las personas, considero que lo más importante es obtener la mejor precisión posible. Es de suma importancia priorizar esta métrica para la clase 0. . Las 4 personas que el modelo de Random Forest predijo como clase 0 cuando en realidad eran clase 4 (máximo grado de severidad posible de enfermedad cardíaca) es un error muy grave. Sin embargo, el modelo de GradientBoostedTrees solo se equivocó con casos de la clase 1 (menor grado de severidad) y en menor medida que el otro modelo (por lo tanto tiene mayor precision). También, el modelo de boosted tres posee un mayor recall para la clase 0, lo cual es un extra. . Resumiendo, por la mejor precisión para la clase 0 y por el accuracy comparable al modelo con mejor accuracy que posee el modelo de GradientBoostedTrees, este es el mejor modelo para este caso de estudio. . 5- Conclusiones generales sobre el caso abordado y la viabilidad u oportunidad de aplicación de técnicas de machine learning en el mismo. . Comparando los resultados obtenidos por el modelo elegido, este posee una mayor exactitud (no tenemos la precisión) que la que obtuvieron múltiples estudios rigurosos en 1989 citados en las referencias de este caso de estudio[5]. Se utilizó una mayor cantidad de atributos (sin abarcar la totalidad de los atributos elegidos por dichos estudios) y un algoritmo más moderno que los que había en la época de los estudios. Es debido a estas razones que se consiguieron mejores resultados. . En cuanto a la viabilidad de la aplicación de técnicas de machine learning para predicción de enfermedad cardíaca, si las personas están dispuestas a generar los datos (sus datos personales) necesarios para que se pueda predecir si se tiene la enfermedad o no, está muy claro que se brindaría un gran beneficio a ellas y a la sociedad entera. . Bibliografía . [1] https://www.who.int/news-room/fact-sheets/detail/the-top-10-causes-of-death . [2] Application of Machine Learning Algorithms to Predict Coronary Artery Calcification With a Sibship-Based Design Yan V. Sun1,* , Lawrence F. Bielak1, Patricia A. Peyser1, Stephen T. Turner2, Patrick F. Sheedy II3, Eric Boerwinkle4, and Sharon L.R. Kardia (2008) . [3] Heart Failure: Diagnosis, Severity Estimation and Prediction of Adverse Events Through Machine Learning Techniques Evanthia E. Tripoliti, Theofilos G. Papadopoulos , Georgia S. Karanasiou, Katerina K. Naka, Dimitrios I. Fotiadis (2016) . [4] https://machinelearningmastery.com/bagging-and-random-forest-ensemble-algorithms-for-machine-learning/ . [5] Past Usage: . 1. Detrano,~R., Janosi,~A., Steinbrunn,~W., Pfisterer,~M., Schmid,~J., . Sandhu,~S., Guppy,~K., Lee,~S., &amp; Froelicher,~V. (1989). { it . International application of a new probability algorithm for the . diagnosis of coronary artery disease.} { it American Journal of . Cardiology}, { it 64},304–310. . -- International Probability Analysis . -- Address: Robert Detrano, M.D. . Cardiology 111-C . V.A. Medical Center . 5901 E. 7th Street . Long Beach, CA 90028 . -- Results in percent accuracy: (for 0.5 probability threshold) . Data Name: CDF CADENZA . -- Hungarian 77 74 . Long beach 79 77 . Swiss 81 81 . -- Approximately a 77% correct classification accuracy with a . logistic-regression-derived discriminant function . 2. David W. Aha &amp; Dennis Kibler . -- Instance-based prediction of heart-disease presence with the . Cleveland database . -- NTgrowth: 77.0% accuracy . -- C4: 74.8% accuracy . 3. John Gennari . -- Gennari, J.~H., Langley, P, &amp; Fisher, D. (1989). Models of . incremental concept formation. { it Artificial Intelligence, 40}, . 11–61. . -- Results: . -- The CLASSIT conceptual clustering system achieved a 78.9% accuracy . on the Cleveland database. .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/12/01/Caso-de-Estudio-3-Enfermedad-Card%C3%ADaca.html",
            "relUrl": "/2021/12/01/Caso-de-Estudio-3-Enfermedad-Card%C3%ADaca.html",
            "date": " • Dec 1, 2021"
        }
        
    
  
    
  
    
        ,"post3": {
            "title": "Caso De Estudio 2   Parkinsons Disease Document",
            "content": "Parkinsons Disease Data Set Case Study . 1) Case Study introduction . “Parkinson’s disease is a degenerative brain disorder which usually presents symptoms like stiffness, body tremors, and difficulty maintaining balance and coordination. The symptoms get worse with age and usually start developing around 60 years of age. . There is currently no way to diagnose Parkinson’s using blood or laboratory tests for non-genetic cases. Diagnoses are done using patients’ medical history and neurological exams. It is important to diagnose Parkinson’s early, due to very similar symptoms it has to other diseases which require different treatments.”[1] . 2) Brief description of the data set and a summary of its attributes . The dataset was created by Max Little (University of Oxford) in collaboration with the National Centre for Voice and Speech (Denver, Colorado), who recorded speech signals. . It contains biomedical voice measurements from 31 people, 23 with Parkinson’s disease. The attributes are particular voice measures, and the examples correspond with the 195 voice recordings. . Attributes: . name - ASCII subject name and recording number . MDVP:Fo(Hz) - Average vocal fundamental frequency . MDVP:Fhi(Hz) - Maximum vocal fundamental frequency . MDVP:Flo(Hz) - Minimum vocal fundamental frequency . MDVP:Jitter(%),MDVP:Jitter(Abs),MDVP:RAP,MDVP:PPQ,Jitter:DDP - Several . measures of variation in fundamental frequency . MDVP:Shimmer,MDVP:Shimmer(dB),Shimmer:APQ3,Shimmer:APQ5,MDVP:APQ,Shimmer:DDA - Several measures of variation in amplitude . NHR,HNR - Two measures of ratio of noise to tonal components in the voice . status - Health status of the subject (one) - Parkinson’s, (zero) - healthy . RPDE,D2 - Two nonlinear dynamical complexity measures . DFA - Signal fractal scaling exponent . spread1,spread2,PPE - Three nonlinear measures of fundamental frequency variation . (Attribute information from Parkinson.names file in the UCI Repository). . All attributes but name (pacient name) and status (pacient has the disease (1) or not (0)) are real values. The pacient name is not important as it shouldn’t have any descriptive insight to whether a person has Parkinson or not, so we will later remove that attribute. This makes all our predictors real values. . 3) Initial plan for data exploration . The initial plan is to explore attribute distributions, correlations and detect outliers within the distributions. . First, I have decided to plot (sns pairplot) one of each type of attribute so as to have a clearer visualization than if we had called sns pairplot on the entire dataset. By type of attribute im referring to choosing only one predictor that models a certain characteristic. For example, I only plot NHR instead of plotting NHR and HNR in order to reduce the number of graphs created. . . By checking at some pairs of attributes, we can notice some degree of separation between both classes. For example, we can see that when comparing NHR and spread1, patients who have parkinsons disease have higher values of spread 1 than patients who don’t have the disease. The outlier points in the majority of the plots tend to belong to the parkinsons class too. . The highest correlations between attributes and status are 0.56 (spread1) and 0.53 (PPE). . 4) Feature engineering and data cleaning . Regarding Data cleaning, not much is required for the selected dataset. We don’t have highly correlated columns and there are no null values. Thus we don’t need to think about which would be the best strategy (imputation, drop column, drop row, etc.). The only cleaning made was to drop the “pacient name” attribute. . As for feature engineering, I have noticed the dataset has some attributes whose distribution is heavily skewed. . . Due to this fact, I have decided to use a log transformation for attributes with a skew value greater than 1. This makes the distribution of the transformed predictors to resemble a gaussian distribution, which is a prerequisite for many ML algorithms. . Attributes’ distribution after transformation: . . The next step is to normalize the data. I chose to use z transformation, but Min-Max normalization is another option . . 5) Key findings and insights . By comparing the distributions of parkinson patients’ attributes with non- parkinson patients’ attributes, we can identify some insights which were previously mentioned. The range of values in almost all of the attributes is undeniably greater than the one In attributes of non- parkinson patients. This could be a key insight when trying to predict a parkinson patient. For example, if spread1 is greater than -4, we could infer that the patient has parkinson. Also, the higher spread1 is, the more likely a given patient has parkinson. Also, outlier points tend to correspond with patients who have the disease. . 6) Formulate hypothesis and . 7) Conduct a formal significance tests, discussing results . 1-Null hypothesis: The mean of spread1 for parkinsons patients is the same than the mean of spread1 for non-parkinsons patients. . Alternative hypothesis: The mean is different . . Thus, we reject the null hypothesis by a great margin. The means are different. . 2-Null hypothesis: The mean of spread1 for parkinsons patients is larger than the mean of spread1 for non-parkinsons patients by at least 1.5 standard deviations of the attribute’s distribution. . Alternative-hypothesis: The mean of spread1 for parkinsons patients is not larger than the mean of spread1 for non-parkinsons patients by at least 1.5 standard deviations of the attribute’s distribution. . . The null hypothesis is accepted, so we can confirm with 95%confidence that the null hypothesis is correct. . 3-Null hypothesis: The mean of DFA for parkinsons patients is larger than the mean of DFA for non-parkinsons patients by at least 1 standard deviation of the attributes distribution. . Alternative-hypothesis: The mean of DFA for parkinsons patients is not larger than the mean of DFA for non-parkinsons patients by at least 1 standard deviation of the attributes distribution. . . The null hypothsis is rejected, so we can’t confirm with a 95% confidence that the mean of DFA for parkinsons’ patients is larger than the mean of DFA for non-parkinsons’ patients by at least 1 standard deviation of the attributes distribution. . 8) Suggestions for next steps in analyzing this data. . I would suggest to analyze and compare the distributions of attributes within the same attribute types (attributes that measure the same thing). It is important to separate the distributions by status, so we can check the distribution for parkinsons patients and non-parkinsons patients. . Also, we could implement Principal component analysis to check which attributes have the greatest variance. . 9) Summary of quality of data . I believe the quality of the dataset is decent. There are no missing values and you can visually have an idea of which attributes are going to have a greater effect on predictions (such as spread1). . However, the dataset only has 195 rows, so we could be building this whole EDA on a biased small group of individuals. If more data could be generated with patients from different parts of the world, different age ranges and social status, I would be more confident that the model generated with this data would be a solid one, capable of making correct predictions from samples all round the world. . References: . [1]: https://www.beloit.edu/live/profiles/2530-employing-data-mining-techniques-on-biomedical . https://archive.ics.uci.edu/ml/datasets/parkinsons . Required Citations:  ’Exploiting Nonlinear Recurrence and Fractal Scaling Properties for Voice Disorder Detection’, Little MA, McSharry PE, Roberts SJ, Costello DAE, Moroz IM. BioMedical Engineering OnLine 2007, 6:23 (26 June 2007) .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/11/12/Caso-de-Estudio-2-Parkinsons-Disease-Document.html",
            "relUrl": "/2021/11/12/Caso-de-Estudio-2-Parkinsons-Disease-Document.html",
            "date": " • Nov 12, 2021"
        }
        
    
  
    
  
    
        ,"post5": {
            "title": "Diferentes Estrategias Para Feature Selection   Dataset Sonar",
            "content": "Feature selection para el dataset Sonar . Feature selection es una estrategia muy importante para generar modelos buenos y robustos. Si mantenemos atributos que contengan una gran cantidad de ruido, identificar los patrones que se buscan en un set de datos será una tarea difícil, hasta para los algoritmos de aprendizaje más modernos. . Por este motivo, existen diferentes técnicas para seleccionar los mejores atributos para nuestro modelo. Estas caen en 2 categorías, las del tipo filtro y las del tipo wrapper. . Las técnicas del tipo filtro refieren a una elección de artibutos a remover sin incluir el proceso de aprendizaje/modelado. Dentro de esta categoría, podemos encontrar a la eliminación de atributos por conocimiento del dataset o a la eliminación de atributos conocidos que no aportan a los modelos (id o nombre en algunos casos). También, técnicas como el análisis de la correlación de los atributos con la salida y entre sí, caen dentro de esta categoría. Por último, otra técnica de tipo filtro sería utilizar PCA, tanto para utilizar los primeros componentes principales en el modelado como para identificar los atributos con coeficientes mayores en el cálculo de los primeros componentes principales. . Por otra parte, las técnicas de tipo wrapper seleccionan predictores de forma iterativa incluyendo los pasos de entrenamiento y validación para decidir cuáles predictores son los que generan los mejores modelos. Como una estrategia de fuerza bruta, o sea probar todas las combinaciones posibles es increíblemente costoso de un punto de vista computacional (orden exponencial – 2 a la n para n atributos), surgen heurísticas variadas para atacar esta problemática. Algunos ejemplos de estas son: forward propagation, backward elimination y evolutionary feature selection. Estas heurísticas serán analizadas a continuación. . Forward Selection . Como primer paso, se generan modelos con cada uno de los predictores del dataset (se utiliza únicamente 1 predictor). El atributo con el que fue entrenado el modelo que obtuvo mejores resultados, será seleccionado y se pasa a la siguiente iteración. Luego, se entrenan modelos con 2 atributos, las combinaciones entre el atributo elegido en el paso anterior y el resto de los predictores (n-1 modelos con n predictores). Dentro de estos modelos, se compara la performance entre sí y con el modelo que utilizó únicamente 1 atributo. Si la performance no mejora respecto al modelo con 1 atributo menos, termina la heurística. Si, efectivamente, se logra obtener una mayor performance, se sigue iterando hasta llegar a la condición de corte mencionada en la oración anterior. Se puede ver que el número de entrenamientos necesarios para esta heurística posee una cota superior dada por la suma de los primeros n naturales de 1 hasta la cantidad de predictores. Esta cantidad de modelos entrenados es mucho menor que la cantidad si utilizamos el enfoque de fuerza bruta (para 100 atributos existen como máximo 5050 combinaciones para forward selection y 1,267,650,600,228,229,401,496,703,205,375 para el enfoque de fuerza bruta). . Backward elimination . Esta heurística se puede pensar como la opuesta/inversa de forward selection. En vez de empezar con 0 e ir agregando atributos iterativamente, aquí se comienza con la totalidad de los predictores. Luego de entrenar el primer modelo con todos los atributos, se mide la performance de los modelos que poseen todos los predictores menos 1. Si existe alguno de estos nuevos modelos que posea una mejor performance que la que obtuvo el modelo de la iteración anterior (modelo entrenado con todos los predictores), se descarta el atributo no utilizado y se itera nuevamente. En el caso que la performance no mejore, termina la heurística. . Las 2 heurísticas mencionadas son claramente mucho más eficientes desde el punto de vista computacional que la fuerza bruta, pero tienen sus desventajas. Son muy susceptibles a seleccionar óptimos locales y no el óptimo global. Debido a esto, la performance obtenida con estos enfoques normalmente es inferior a la obtenida con el enfoque de fuerza bruta. Entonces, ¿cuál sería nuestra opción si quisiéramos lo mejor de los dos mundos? . Algoritmos Evolutivos para la selección de atributos. . Los algoritmos evolutivos son una técnica de optimización que se basa en la selección natural. En resumen, esta estrategia funciona inicialmente generando una población inicial (combinaciones de predictores en nuestro caso). Luego, de forma iterativa hasta llegar a un máximo de iteraciones (se les llama generaciones) o a alguna otra condición de corte, se aplican los siguientes pasos. Cruzamiento: Se cruzan los individuos de la población. Mutación: se muta a los individuos (normalmente involucra un cambio pequeño randómico como seleccionar un atributo nuevo o des-seleccionar uno). Evaluación: se evalúa a la población. En nuestro caso esto se hará con la exactitud (por ejemplo) de los modelos generados con los atributos representados por cada individuo de la población. Selección: se seleccionan losindividuos que posean mejores métricas. . Esta estrategia, aunque tiene un costo computacional mayor que las 2 heurísticas antes mencionadas, suele llegar al óptimo global o de los contrario a una solución mejor que la obtenida con dichas heurísticas. El costo igualmente, no se compara con el de la fuerza bruta. . Dataset Sonar . Este dataset contiene medidas realizadas al fondo marino utilizando un sonar. Cada medida (ejemplo) contiene múltiples bandas de frecuencia (predictores) y una clase definida: rock o mine. La idea es poder detectar la presencia de minas en el fondo marino. Al graficar los datos, se puede observar el espectro de frecuencia para cada objeto. Dichos espectros, difieren claramente en algunas zonas específicas. Se definen los siguientes intervalos de atributos como zonas de interés. La idea es utilizar diferentes técnicas de feature selection para observar los atributos que se eligen y la performance que se obtiene. . Intervalos . 1) 9-13 . 2) 19-25 . 3) 33-37 . 4) 42-50 . Ejercicio 1: Benchmarking . Se entrena un modelo con todos los predictores y el algoritmo naive bayes. . Se obtienen los mismos resultados con o sin la corrección de Laplace. . ## . ## . Ejercicio 2: Forward selection . Se entrena un modelo con los predictores seleccionados con la heurística forward selection y el algoritmo naive bayes. . . Atributos seleccionados: 12, 15, 17, 18 . El algoritmo encuentra un máximo local (atributo 12) en 4 iteraciones. . Ejercicio 3: Backward Elimination . Se entrena un modelo con los predictores seleccionados con la heurística backward elimination y el algoritmo naive bayes. . . Atributos descartados: 3, 14, 20, 36, 47, 48, 52, 59 . Ejercicio 4 . Se entrena un modelo con los predictores seleccionados con una estrategia evolutiva y el algoritmo naive bayes. . . . Análisis personal de los resultados . La mejor exactitud fue obtenida por el modelo en el que se utilizó el enfoque genético para la selección de atributos. Igualmente, considero que se eligieron demasiados atributos, muchos de los cuales no hacen más que incluir ruido en el modelo. . Debido a esto, decido indagar más en los parámetros del bloque optimize selection y encuentro una opción con la que se puede limitar la cantidad de atributos seleccionados. Escojo el valor 10. Los resultados son los siguientes. . 10 atributos: . . Se obtuvieron mejores resultados y los atributos seleccionados tienen más sentido cuando se los compara con los intervalos en los que las 2 gráficas (mine y rock) están más separadas. .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/10/10/Diferentes-estrategias-para-Feature-Selection-Dataset-Sonar.html",
            "relUrl": "/2021/10/10/Diferentes-estrategias-para-Feature-Selection-Dataset-Sonar.html",
            "date": " • Oct 10, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Clustering",
            "content": "Clustering . En este post me gustaría hablar sobre diferentes estrategias de clustering de datos para problemas supervisados y no supervisados. . Previo a un análisis de casos especiales, me parece pertinente hacer una breve introducción al concepto de clustering. Supongamos que se tiene un conjunto de datos estructurado o tabular como por ejemplo un archivo .csv. En él habrá una gran cantidad de filas o ejemplos y otra cantidad de columnas o atributos. ¿Cómo podríamos hacer para extraer información relevante de este conjunto de datos? Si nuestro dataset contiene información de clientes de un supermercado y de los artículos que este compra, algo que podríamos querer hacer es agrupar a diferentes tipos de clientes para poder realizar ofertas direccionadas. El proceso de agrupar o armar clusters es lo que se conoce como clustering y tiene el propósito de extraer información mediante diferentes formas de agrupación. . Hierarchical clustering . El clustering jerárquico es un método de análisis de clusters que busca construir una jerarquía de clusters. Este tipo de clustering se basa en la idea que explica que un objeto está más relacionado con un objeto cercano que con uno que está a una distancia mayor. Por lo tanto, el clustering jerárquico conecta objetos o ejemplos basándose en la distancia entre ambos. A distancias diferentes, se formarán distintos clusters, que se pueden representar utilizando un dendograma. . Existen 2 estrategias para clustering jerárquico: . Agglomerative: Cada ejemplo comienza en su cluster propio y a medida que se aumenta la distancia (a medida que nos movemos hacia arriba en la jerarquía), se irán formando las agrupaciones. . Divisive: Los ejemplos comienzan agrupadops en un único cluster y se van separando recursivamente a medida que bajamos en la jerarquía. . Existen diferentes modos de medir las distancias entre clusters. Cada una tiene sus casos de aplicación particular, pero en el siguiente ejercicio, analizaremos el propósito de 2 de estos modos (complete link y single link). . K-Means . K-means es un tipo de clustering en el que el número de clusters a generar es un parámetro del algoritmo (k). Este algoritmo iniciará escogiendo k puntos aleatorios del dataset (centroides) y asignando un cluster a cada punto del dataset dependiendo de qué centroide esté más cerca de él. Luego, de forma iterativa, se vuelven a calcular los centroides tal que estos centroides (no necesariamente pertenecientes al dataset) minimicen la suma de las distancias a todos los puntos del cluster. Luego, se reclusterizan los puntos dependiendo de la proximidad de los centroides recalculados. La heurística termina cuando los centroides se hayan estabilizado o luego de un número máximo de iteraciones. Este algoritmo no siempre devuelve los mismos agrupamientos debido a la inicialización randómica de los centroides, por lo que es una buena práctica correr el algoritmo múltiples veces. . Ejercicio . Se desea agrupar los ejemplos del dataset ripley provisto por rapidminer en clusters. . Nota: Es de crucial importancia normalizar los atributos previo a realizar clustering, pues las formas de clustering discutidas utilizan la distancia euclídea para medir la similaridad entre ejemplos o clusters. . . Agglomerative clustering . Para el agglomerative clustering, se decide hacer una comparación entre la utilización entre complete link y single link. . Complete link y distancia euclídea . . Single link y distancia euclídea . . Como se puede observar en las imágenes anteriores, la utilización de comlpete link obtiene clusters más parejos (uniformes) y distancias intraclusters medias menores que el single link. Aquí ya podemos entender el propósito de la utilización de cada uno. . Si se desea obtener clusters uniformes y parejos, la mejor forma de medir distancias entre clusters es complete link. . Si, por el contrario se desea localizar datos extremos o outliers, single link es la forma de distancia a elegir. . Resultados para agglomerative clustering con complete link: . Avg. within cluster distance: -31.972 . Avg. within cluster distance for cluster 0: -37.551 . Avg. within cluster distance for cluster 1: -13.095 . Avg. within cluster distance for cluster 2: -34.942 . Top-Down Clustering . En cuanto a top-down clustering, se decide utilizar k-means con Max depth=5 y . Max leaf size=1. . . Resultados: . kmeans k=2 . Avg. within cluster distance: -36.971 . Avg. within cluster distance for cluster 0: -55.705 . Avg. within cluster distance for cluster 1: -23.788 . Avg. within cluster distance for cluster 2: -13.534 . Conclusiones . Se puede observar que la estrategia de aglomerative clustering obtuvo una menor distancia promedio intercluster que la estrategia utilizando top-down clustering con kmeans. Debido a esto, podemos argumentar que para este dataset, la mejor estrategia es la de agglomerative clustering . Referencias: . https://docs.rapidminer.com/latest/studio/operators/modeling/segmentation/agglomerative_clustering.html .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/10/09/Clustering.html",
            "relUrl": "/2021/10/09/Clustering.html",
            "date": " • Oct 9, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Title",
            "content": "&quot;Modelado con diferentes algoritmos para predecir sobrevivientes del Titanic&quot; . toc:true- branch: master | badges: true | comments: true | categories: [jupyter, Normalization, DecisionTrees, NaiveBayes, KNN, Ensembles, NaiveBayes, KNN, SVM, LogisticRegression] | image: images/some_folder/your_image.png | hide: false | search_exclude: true | metadata_key1: metadata_value1 | metadata_key2: metadata_value2 | . Disclaimer . Este notebook no es de mi autoría. Apliqué una leve modificación para probar una hipótesis, pero todo el resto del notebook fue obtenido de Kaggle y su autor es Samson Qian. Lo que es de mi autoría es el análisis en el post con igual nombre, que se basa en este notebook. . import numpy as np import pandas as pd import seaborn as sns from matplotlib import pyplot as plt sns.set_style(&quot;whitegrid&quot;) %matplotlib inline import warnings warnings.filterwarnings(&quot;ignore&quot;) import os print(os.listdir(&quot;./input&quot;)) . [&#39;gender_submission.csv&#39;, &#39;test.csv&#39;, &#39;train.csv&#39;] . training = pd.read_csv(&quot;./input/train.csv&quot;) testing = pd.read_csv(&quot;./input/test.csv&quot;) . training.head() . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . testing.head() . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . print(training.keys()) print(testing.keys()) . Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . types_train = training.dtypes num_values = types_train[(types_train == float)] print(&quot;These are the numerical features:&quot;) print(num_values) . These are the numerical features: Age float64 Fare float64 dtype: object . training.describe() . PassengerId Survived Pclass Age SibSp Parch Fare . count 891.000000 | 891.000000 | 891.000000 | 714.000000 | 891.000000 | 891.000000 | 891.000000 | . mean 446.000000 | 0.383838 | 2.308642 | 29.699118 | 0.523008 | 0.381594 | 32.204208 | . std 257.353842 | 0.486592 | 0.836071 | 14.526497 | 1.102743 | 0.806057 | 49.693429 | . min 1.000000 | 0.000000 | 1.000000 | 0.420000 | 0.000000 | 0.000000 | 0.000000 | . 25% 223.500000 | 0.000000 | 2.000000 | 20.125000 | 0.000000 | 0.000000 | 7.910400 | . 50% 446.000000 | 0.000000 | 3.000000 | 28.000000 | 0.000000 | 0.000000 | 14.454200 | . 75% 668.500000 | 1.000000 | 3.000000 | 38.000000 | 1.000000 | 0.000000 | 31.000000 | . max 891.000000 | 1.000000 | 3.000000 | 80.000000 | 8.000000 | 6.000000 | 512.329200 | . def null_table(training, testing): print(&quot;Training Data Frame&quot;) print(pd.isnull(training).sum()) print(&quot; &quot;) print(&quot;Testing Data Frame&quot;) print(pd.isnull(testing).sum()) null_table(training, testing) . Training Data Frame PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 Testing Data Frame PassengerId 0 Pclass 0 Name 0 Sex 0 Age 86 SibSp 0 Parch 0 Ticket 0 Fare 1 Cabin 327 Embarked 0 dtype: int64 . training.drop(labels = [&quot;Cabin&quot;, &quot;Ticket&quot;], axis = 1, inplace = True) testing.drop(labels = [&quot;Cabin&quot;, &quot;Ticket&quot;], axis = 1, inplace = True) null_table(training, testing) . Training Data Frame PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Fare 0 Embarked 2 dtype: int64 Testing Data Frame PassengerId 0 Pclass 0 Name 0 Sex 0 Age 86 SibSp 0 Parch 0 Fare 1 Embarked 0 dtype: int64 . copy = training.copy() copy.dropna(inplace = True) sns.distplot(copy[&quot;Age&quot;]) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2b20ad90400&gt; . sns.distplot(copy[&quot;Fare&quot;]) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2b20ae2e190&gt; . training[&quot;Age&quot;].fillna(training[&quot;Age&quot;].median(), inplace = True) testing[&quot;Age&quot;].fillna(testing[&quot;Age&quot;].median(), inplace = True) training[&quot;Embarked&quot;].fillna(&quot;S&quot;, inplace = True) testing[&quot;Fare&quot;].fillna(testing[&quot;Fare&quot;].median(), inplace = True) null_table(training, testing) . Training Data Frame PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Fare 0 Embarked 0 dtype: int64 Testing Data Frame PassengerId 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Fare 0 Embarked 0 dtype: int64 . training.head() . PassengerId Survived Pclass Name Sex Age SibSp Parch Fare Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | 7.2500 | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | 71.2833 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | 7.9250 | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 53.1000 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 8.0500 | S | . sns.barplot(x=&quot;Sex&quot;, y=&quot;Survived&quot;, data=training) plt.title(&quot;Distribution of Survival based on Gender&quot;) plt.show() total_survived_females = training[training.Sex == &quot;female&quot;][&quot;Survived&quot;].sum() total_survived_males = training[training.Sex == &quot;male&quot;][&quot;Survived&quot;].sum() print(&quot;Total people survived is: &quot; + str((total_survived_females + total_survived_males))) print(&quot;Proportion of Females who survived:&quot;) print(total_survived_females/(total_survived_females + total_survived_males)) print(&quot;Proportion of Males who survived:&quot;) print(total_survived_males/(total_survived_females + total_survived_males)) . Total people survived is: 342 Proportion of Females who survived: 0.6812865497076024 Proportion of Males who survived: 0.31871345029239767 . sns.barplot(x=&quot;Pclass&quot;, y=&quot;Survived&quot;, data=training) plt.ylabel(&quot;Survival Rate&quot;) plt.title(&quot;Distribution of Survival Based on Class&quot;) plt.show() total_survived_one = training[training.Pclass == 1][&quot;Survived&quot;].sum() total_survived_two = training[training.Pclass == 2][&quot;Survived&quot;].sum() total_survived_three = training[training.Pclass == 3][&quot;Survived&quot;].sum() total_survived_class = total_survived_one + total_survived_two + total_survived_three print(&quot;Total people survived is: &quot; + str(total_survived_class)) print(&quot;Proportion of Class 1 Passengers who survived:&quot;) print(total_survived_one/total_survived_class) print(&quot;Proportion of Class 2 Passengers who survived:&quot;) print(total_survived_two/total_survived_class) print(&quot;Proportion of Class 3 Passengers who survived:&quot;) print(total_survived_three/total_survived_class) . Total people survived is: 342 Proportion of Class 1 Passengers who survived: 0.39766081871345027 Proportion of Class 2 Passengers who survived: 0.2543859649122807 Proportion of Class 3 Passengers who survived: 0.347953216374269 . sns.barplot(x=&quot;Pclass&quot;, y=&quot;Survived&quot;, hue=&quot;Sex&quot;, data=training) plt.ylabel(&quot;Survival Rate&quot;) plt.title(&quot;Survival Rates Based on Gender and Class&quot;) . Text(0.5, 1.0, &#39;Survival Rates Based on Gender and Class&#39;) . sns.barplot(x=&quot;Sex&quot;, y=&quot;Survived&quot;, hue=&quot;Pclass&quot;, data=training) plt.ylabel(&quot;Survival Rate&quot;) plt.title(&quot;Survival Rates Based on Gender and Class&quot;) . Text(0.5, 1.0, &#39;Survival Rates Based on Gender and Class&#39;) . survived_ages = training[training.Survived == 1][&quot;Age&quot;] not_survived_ages = training[training.Survived == 0][&quot;Age&quot;] plt.subplot(1, 2, 1) sns.distplot(survived_ages, kde=False) plt.axis([0, 100, 0, 100]) plt.title(&quot;Survived&quot;) plt.ylabel(&quot;Proportion&quot;) plt.subplot(1, 2, 2) sns.distplot(not_survived_ages, kde=False) plt.axis([0, 100, 0, 100]) plt.title(&quot;Didn&#39;t Survive&quot;) plt.subplots_adjust(right=1.7) plt.show() . sns.stripplot(x=&quot;Survived&quot;, y=&quot;Age&quot;, data=training, jitter=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2b20af1f4f0&gt; . sns.pairplot(training) . &lt;seaborn.axisgrid.PairGrid at 0x2b20a537ca0&gt; . training.sample(5) . PassengerId Survived Pclass Name Sex Age SibSp Parch Fare Embarked . 103 104 | 0 | 3 | Johansson, Mr. Gustaf Joel | male | 33.0 | 0 | 0 | 8.6542 | S | . 444 445 | 1 | 3 | Johannesen-Bratthammer, Mr. Bernt | male | 28.0 | 0 | 0 | 8.1125 | S | . 392 393 | 0 | 3 | Gustafsson, Mr. Johan Birger | male | 28.0 | 2 | 0 | 7.9250 | S | . 340 341 | 1 | 2 | Navratil, Master. Edmond Roger | male | 2.0 | 1 | 1 | 26.0000 | S | . 854 855 | 0 | 2 | Carter, Mrs. Ernest Courtenay (Lilian Hughes) | female | 44.0 | 1 | 0 | 26.0000 | S | . testing.sample(5) . PassengerId Pclass Name Sex Age SibSp Parch Fare Embarked . 190 1082 | 2 | Angle, Mr. William A | male | 34.0 | 1 | 0 | 26.0000 | S | . 315 1207 | 3 | Hagardon, Miss. Kate | female | 17.0 | 0 | 0 | 7.7333 | Q | . 389 1281 | 3 | Palsson, Master. Paul Folke | male | 6.0 | 3 | 1 | 21.0750 | S | . 391 1283 | 1 | Lines, Mrs. Ernest H (Elizabeth Lindsey James) | female | 51.0 | 0 | 1 | 39.4000 | S | . 41 933 | 1 | Franklin, Mr. Thomas Parham | male | 27.0 | 0 | 0 | 26.5500 | S | . set(training[&quot;Embarked&quot;]) . {&#39;C&#39;, &#39;Q&#39;, &#39;S&#39;} . from sklearn.preprocessing import LabelEncoder le_sex = LabelEncoder() le_sex.fit(training[&quot;Sex&quot;]) encoded_sex_training = le_sex.transform(training[&quot;Sex&quot;]) training[&quot;Sex&quot;] = encoded_sex_training encoded_sex_testing = le_sex.transform(testing[&quot;Sex&quot;]) testing[&quot;Sex&quot;] = encoded_sex_testing le_embarked = LabelEncoder() le_embarked.fit(training[&quot;Embarked&quot;]) encoded_embarked_training = le_embarked.transform(training[&quot;Embarked&quot;]) training[&quot;Embarked&quot;] = encoded_embarked_training encoded_embarked_testing = le_embarked.transform(testing[&quot;Embarked&quot;]) testing[&quot;Embarked&quot;] = encoded_embarked_testing #Here&#39;s how to do it manually in Python without packages &quot;&quot;&quot; training.loc[training[&quot;Sex&quot;] == &quot;male&quot;, &quot;Sex&quot;] = 0 training.loc[training[&quot;Sex&quot;] == &quot;female&quot;, &quot;Sex&quot;] = 1 training.loc[training[&quot;Embarked&quot;] == &quot;S&quot;, &quot;Embarked&quot;] = 0 training.loc[training[&quot;Embarked&quot;] == &quot;C&quot;, &quot;Embarked&quot;] = 1 training.loc[training[&quot;Embarked&quot;] == &quot;Q&quot;, &quot;Embarked&quot;] = 2 testing.loc[testing[&quot;Sex&quot;] == &quot;male&quot;, &quot;Sex&quot;] = 0 testing.loc[testing[&quot;Sex&quot;] == &quot;female&quot;, &quot;Sex&quot;] = 1 testing.loc[testing[&quot;Embarked&quot;] == &quot;S&quot;, &quot;Embarked&quot;] = 0 testing.loc[testing[&quot;Embarked&quot;] == &quot;C&quot;, &quot;Embarked&quot;] = 1 testing.loc[testing[&quot;Embarked&quot;] == &quot;Q&quot;, &quot;Embarked&quot;] = 2 &quot;&quot;&quot; . &#39; ntraining.loc[training[&#34;Sex&#34;] == &#34;male&#34;, &#34;Sex&#34;] = 0 ntraining.loc[training[&#34;Sex&#34;] == &#34;female&#34;, &#34;Sex&#34;] = 1 n ntraining.loc[training[&#34;Embarked&#34;] == &#34;S&#34;, &#34;Embarked&#34;] = 0 ntraining.loc[training[&#34;Embarked&#34;] == &#34;C&#34;, &#34;Embarked&#34;] = 1 ntraining.loc[training[&#34;Embarked&#34;] == &#34;Q&#34;, &#34;Embarked&#34;] = 2 n ntesting.loc[testing[&#34;Sex&#34;] == &#34;male&#34;, &#34;Sex&#34;] = 0 ntesting.loc[testing[&#34;Sex&#34;] == &#34;female&#34;, &#34;Sex&#34;] = 1 n ntesting.loc[testing[&#34;Embarked&#34;] == &#34;S&#34;, &#34;Embarked&#34;] = 0 ntesting.loc[testing[&#34;Embarked&#34;] == &#34;C&#34;, &#34;Embarked&#34;] = 1 ntesting.loc[testing[&#34;Embarked&#34;] == &#34;Q&#34;, &#34;Embarked&#34;] = 2 n&#39; . training.sample(5) . PassengerId Survived Pclass Name Sex Age SibSp Parch Fare Embarked . 442 443 | 0 | 3 | Petterson, Mr. Johan Emil | 1 | 25.0 | 1 | 0 | 7.7750 | 2 | . 641 642 | 1 | 1 | Sagesser, Mlle. Emma | 0 | 24.0 | 0 | 0 | 69.3000 | 0 | . 178 179 | 0 | 2 | Hale, Mr. Reginald | 1 | 30.0 | 0 | 0 | 13.0000 | 2 | . 625 626 | 0 | 1 | Sutton, Mr. Frederick | 1 | 61.0 | 0 | 0 | 32.3208 | 2 | . 7 8 | 0 | 3 | Palsson, Master. Gosta Leonard | 1 | 2.0 | 3 | 1 | 21.0750 | 2 | . testing.sample(5) . PassengerId Pclass Name Sex Age SibSp Parch Fare Embarked . 57 949 | 3 | Abelseth, Mr. Olaus Jorgensen | 1 | 25.0 | 0 | 0 | 7.6500 | 2 | . 293 1185 | 1 | Dodge, Dr. Washington | 1 | 53.0 | 1 | 1 | 81.8583 | 2 | . 191 1083 | 1 | Salomon, Mr. Abraham L | 1 | 27.0 | 0 | 0 | 26.0000 | 2 | . 396 1288 | 3 | Colbert, Mr. Patrick | 1 | 24.0 | 0 | 0 | 7.2500 | 1 | . 122 1014 | 1 | Schabert, Mrs. Paul (Emma Mock) | 0 | 35.0 | 1 | 0 | 57.7500 | 0 | . training[&quot;FamSize&quot;] = training[&quot;SibSp&quot;] + training[&quot;Parch&quot;] + 1 testing[&quot;FamSize&quot;] = testing[&quot;SibSp&quot;] + testing[&quot;Parch&quot;] + 1 . training[&quot;IsAlone&quot;] = training.FamSize.apply(lambda x: 1 if x == 1 else 0) testing[&quot;IsAlone&quot;] = testing.FamSize.apply(lambda x: 1 if x == 1 else 0) . for name in training[&quot;Name&quot;]: training[&quot;Title&quot;] = training[&quot;Name&quot;].str.extract(&quot;([A-Za-z]+) .&quot;,expand=True) for name in testing[&quot;Name&quot;]: testing[&quot;Title&quot;] = testing[&quot;Name&quot;].str.extract(&quot;([A-Za-z]+) .&quot;,expand=True) . training.head() #Title column added . PassengerId Survived Pclass Name Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | 1 | 22.0 | 1 | 0 | 7.2500 | 2 | 2 | 0 | Mr | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | 0 | 38.0 | 1 | 0 | 71.2833 | 0 | 2 | 0 | Mrs | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | 0 | 26.0 | 0 | 0 | 7.9250 | 2 | 1 | 1 | Miss | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | 0 | 35.0 | 1 | 0 | 53.1000 | 2 | 2 | 0 | Mrs | . 4 5 | 0 | 3 | Allen, Mr. William Henry | 1 | 35.0 | 0 | 0 | 8.0500 | 2 | 1 | 1 | Mr | . titles = set(training[&quot;Title&quot;]) #making it a set gets rid of all duplicates print(titles) . {&#39;Rev&#39;, &#39;Mme&#39;, &#39;Col&#39;, &#39;Sir&#39;, &#39;Major&#39;, &#39;Mr&#39;, &#39;Jonkheer&#39;, &#39;Don&#39;, &#39;Ms&#39;, &#39;Mlle&#39;, &#39;Lady&#39;, &#39;Capt&#39;, &#39;Master&#39;, &#39;Countess&#39;, &#39;Dr&#39;, &#39;Miss&#39;, &#39;Mrs&#39;} . title_list = list(training[&quot;Title&quot;]) frequency_titles = [] for i in titles: frequency_titles.append(title_list.count(i)) print(frequency_titles) . [6, 1, 2, 1, 2, 517, 1, 1, 1, 2, 1, 1, 40, 1, 7, 182, 125] . titles = list(titles) title_dataframe = pd.DataFrame({ &quot;Titles&quot; : titles, &quot;Frequency&quot; : frequency_titles }) print(title_dataframe) . Titles Frequency 0 Rev 6 1 Mme 1 2 Col 2 3 Sir 1 4 Major 2 5 Mr 517 6 Jonkheer 1 7 Don 1 8 Ms 1 9 Mlle 2 10 Lady 1 11 Capt 1 12 Master 40 13 Countess 1 14 Dr 7 15 Miss 182 16 Mrs 125 . title_replacements = {&quot;Mlle&quot;: &quot;Other&quot;, &quot;Major&quot;: &quot;Other&quot;, &quot;Col&quot;: &quot;Other&quot;, &quot;Sir&quot;: &quot;Other&quot;, &quot;Don&quot;: &quot;Other&quot;, &quot;Mme&quot;: &quot;Other&quot;, &quot;Jonkheer&quot;: &quot;Other&quot;, &quot;Lady&quot;: &quot;Other&quot;, &quot;Capt&quot;: &quot;Other&quot;, &quot;Countess&quot;: &quot;Other&quot;, &quot;Ms&quot;: &quot;Other&quot;, &quot;Dona&quot;: &quot;Other&quot;} training.replace({&quot;Title&quot;: title_replacements}, inplace=True) testing.replace({&quot;Title&quot;: title_replacements}, inplace=True) le_title = LabelEncoder() le_title.fit(training[&quot;Title&quot;]) encoded_title_training = le_title.transform(training[&quot;Title&quot;]) training[&quot;Title&quot;] = encoded_title_training encoded_title_testing = le_title.transform(testing[&quot;Title&quot;]) testing[&quot;Title&quot;] = encoded_title_testing #Again, here&#39;s how to do it manually &quot;&quot;&quot; training.loc[training[&quot;Title&quot;] == &quot;Miss&quot;, &quot;Title&quot;] = 0 training.loc[training[&quot;Title&quot;] == &quot;Mr&quot;, &quot;Title&quot;] = 1 training.loc[training[&quot;Title&quot;] == &quot;Mrs&quot;, &quot;Title&quot;] = 2 training.loc[training[&quot;Title&quot;] == &quot;Master&quot;, &quot;Title&quot;] = 3 training.loc[training[&quot;Title&quot;] == &quot;Dr&quot;, &quot;Title&quot;] = 4 training.loc[training[&quot;Title&quot;] == &quot;Rev&quot;, &quot;Title&quot;] = 5 training.loc[training[&quot;Title&quot;] == &quot;Other&quot;, &quot;Title&quot;] = 6 testing.loc[testing[&quot;Title&quot;] == &quot;Miss&quot;, &quot;Title&quot;] = 0 testing.loc[testing[&quot;Title&quot;] == &quot;Mr&quot;, &quot;Title&quot;] = 1 testing.loc[testing[&quot;Title&quot;] == &quot;Mrs&quot;, &quot;Title&quot;] = 2 testing.loc[testing[&quot;Title&quot;] == &quot;Master&quot;, &quot;Title&quot;] = 3 testing.loc[testing[&quot;Title&quot;] == &quot;Dr&quot;, &quot;Title&quot;] = 4 testing.loc[testing[&quot;Title&quot;] == &quot;Rev&quot;, &quot;Title&quot;] = 5 testing.loc[testing[&quot;Title&quot;] == &quot;Other&quot;, &quot;Title&quot;] = 6 &quot;&quot;&quot; . &#39; ntraining.loc[training[&#34;Title&#34;] == &#34;Miss&#34;, &#34;Title&#34;] = 0 ntraining.loc[training[&#34;Title&#34;] == &#34;Mr&#34;, &#34;Title&#34;] = 1 ntraining.loc[training[&#34;Title&#34;] == &#34;Mrs&#34;, &#34;Title&#34;] = 2 ntraining.loc[training[&#34;Title&#34;] == &#34;Master&#34;, &#34;Title&#34;] = 3 ntraining.loc[training[&#34;Title&#34;] == &#34;Dr&#34;, &#34;Title&#34;] = 4 ntraining.loc[training[&#34;Title&#34;] == &#34;Rev&#34;, &#34;Title&#34;] = 5 ntraining.loc[training[&#34;Title&#34;] == &#34;Other&#34;, &#34;Title&#34;] = 6 n ntesting.loc[testing[&#34;Title&#34;] == &#34;Miss&#34;, &#34;Title&#34;] = 0 ntesting.loc[testing[&#34;Title&#34;] == &#34;Mr&#34;, &#34;Title&#34;] = 1 ntesting.loc[testing[&#34;Title&#34;] == &#34;Mrs&#34;, &#34;Title&#34;] = 2 ntesting.loc[testing[&#34;Title&#34;] == &#34;Master&#34;, &#34;Title&#34;] = 3 ntesting.loc[testing[&#34;Title&#34;] == &#34;Dr&#34;, &#34;Title&#34;] = 4 ntesting.loc[testing[&#34;Title&#34;] == &#34;Rev&#34;, &#34;Title&#34;] = 5 ntesting.loc[testing[&#34;Title&#34;] == &#34;Other&#34;, &#34;Title&#34;] = 6 n&#39; . training.drop(&quot;Name&quot;, axis = 1, inplace = True) testing.drop(&quot;Name&quot;, axis = 1, inplace = True) . training.sample(5) . PassengerId Survived Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 333 334 | 0 | 3 | 1 | 16.0 | 2 | 0 | 18.0000 | 2 | 3 | 0 | 3 | . 647 648 | 1 | 1 | 1 | 56.0 | 0 | 0 | 35.5000 | 0 | 1 | 1 | 5 | . 315 316 | 1 | 3 | 0 | 26.0 | 0 | 0 | 7.8542 | 2 | 1 | 1 | 2 | . 202 203 | 0 | 3 | 1 | 34.0 | 0 | 0 | 6.4958 | 2 | 1 | 1 | 3 | . 422 423 | 0 | 3 | 1 | 29.0 | 0 | 0 | 7.8750 | 2 | 1 | 1 | 3 | . corr = training.corr() corr.head(20) . PassengerId Survived Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . PassengerId 1.000000 | -0.005007 | -0.035144 | 0.042939 | 0.034212 | -0.057527 | -0.001652 | 0.012658 | 0.013128 | -0.040143 | 0.057462 | 0.063978 | . Survived -0.005007 | 1.000000 | -0.338481 | -0.543351 | -0.064910 | -0.035322 | 0.081629 | 0.257307 | -0.167675 | 0.016639 | -0.203367 | -0.060604 | . Pclass -0.035144 | -0.338481 | 1.000000 | 0.131900 | -0.339898 | 0.083081 | 0.018443 | -0.549500 | 0.162098 | 0.065997 | 0.135207 | -0.132099 | . Sex 0.042939 | -0.543351 | 0.131900 | 1.000000 | 0.081163 | -0.114631 | -0.245489 | -0.182333 | 0.108262 | -0.200988 | 0.303646 | 0.023909 | . Age 0.034212 | -0.064910 | -0.339898 | 0.081163 | 1.000000 | -0.233296 | -0.172482 | 0.096688 | -0.018754 | -0.245619 | 0.171647 | 0.413702 | . SibSp -0.057527 | -0.035322 | 0.083081 | -0.114631 | -0.233296 | 1.000000 | 0.414838 | 0.159651 | 0.068230 | 0.890712 | -0.584471 | -0.208276 | . Parch -0.001652 | 0.081629 | 0.018443 | -0.245489 | -0.172482 | 0.414838 | 1.000000 | 0.216225 | 0.039798 | 0.783111 | -0.583398 | -0.096841 | . Fare 0.012658 | 0.257307 | -0.549500 | -0.182333 | 0.096688 | 0.159651 | 0.216225 | 1.000000 | -0.224719 | 0.217138 | -0.271832 | -0.026888 | . Embarked 0.013128 | -0.167675 | 0.162098 | 0.108262 | -0.018754 | 0.068230 | 0.039798 | -0.224719 | 1.000000 | 0.066516 | 0.063532 | 0.006915 | . FamSize -0.040143 | 0.016639 | 0.065997 | -0.200988 | -0.245619 | 0.890712 | 0.783111 | 0.217138 | 0.066516 | 1.000000 | -0.690922 | -0.190730 | . IsAlone 0.057462 | -0.203367 | 0.135207 | 0.303646 | 0.171647 | -0.584471 | -0.583398 | -0.271832 | 0.063532 | -0.690922 | 1.000000 | 0.017792 | . Title 0.063978 | -0.060604 | -0.132099 | 0.023909 | 0.413702 | -0.208276 | -0.096841 | -0.026888 | 0.006915 | -0.190730 | 0.017792 | 1.000000 | . testing.sample(5) . PassengerId Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 218 1110 | 1 | 0 | 50.0 | 1 | 1 | 211.5000 | 0 | 3 | 0 | 4 | . 247 1139 | 2 | 1 | 42.0 | 1 | 1 | 32.5000 | 2 | 3 | 0 | 3 | . 394 1286 | 3 | 1 | 29.0 | 3 | 1 | 22.0250 | 2 | 5 | 0 | 3 | . 334 1226 | 3 | 1 | 27.0 | 0 | 0 | 7.8958 | 2 | 1 | 1 | 3 | . 283 1175 | 3 | 0 | 9.0 | 1 | 1 | 15.2458 | 0 | 3 | 0 | 2 | . from sklearn.preprocessing import StandardScaler scaler = StandardScaler() #We need to reshape our data since the Scaler takes in arrays ages_train = np.array(training[&quot;Age&quot;]).reshape(-1, 1) fares_train = np.array(training[&quot;Fare&quot;]).reshape(-1, 1) ages_test = np.array(testing[&quot;Age&quot;]).reshape(-1, 1) fares_test = np.array(testing[&quot;Fare&quot;]).reshape(-1, 1) training[&quot;Age&quot;] = scaler.fit_transform(ages_train) training[&quot;Fare&quot;] = scaler.fit_transform(fares_train) testing[&quot;Age&quot;] = scaler.fit_transform(ages_test) testing[&quot;Fare&quot;] = scaler.fit_transform(fares_test) #You can try with MinMaxScaler as well to see how it performs in comparison, just replace StandardScaler with MinMaxScaler . training.head() . PassengerId Survived Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 0 1 | 0 | 3 | 1 | -0.565736 | 1 | 0 | -0.502445 | 2 | 2 | 0 | 3 | . 1 2 | 1 | 1 | 0 | 0.663861 | 1 | 0 | 0.786845 | 0 | 2 | 0 | 4 | . 2 3 | 1 | 3 | 0 | -0.258337 | 0 | 0 | -0.488854 | 2 | 1 | 1 | 2 | . 3 4 | 1 | 1 | 0 | 0.433312 | 1 | 0 | 0.420730 | 2 | 2 | 0 | 4 | . 4 5 | 0 | 3 | 1 | 0.433312 | 0 | 0 | -0.486337 | 2 | 1 | 1 | 3 | . testing.head() . PassengerId Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 0 892 | 3 | 1 | 0.386231 | 0 | 0 | -0.497413 | 1 | 1 | 1 | 3 | . 1 893 | 3 | 0 | 1.371370 | 1 | 0 | -0.512278 | 2 | 2 | 0 | 4 | . 2 894 | 2 | 1 | 2.553537 | 0 | 0 | -0.464100 | 1 | 1 | 1 | 3 | . 3 895 | 3 | 1 | -0.204852 | 0 | 0 | -0.482475 | 2 | 1 | 1 | 3 | . 4 896 | 3 | 0 | -0.598908 | 1 | 1 | -0.417492 | 2 | 3 | 0 | 4 | . from sklearn.svm import SVC, LinearSVC from sklearn.ensemble import RandomForestClassifier from sklearn.linear_model import LogisticRegression from sklearn.neighbors import KNeighborsClassifier from sklearn.naive_bayes import GaussianNB from sklearn.tree import DecisionTreeClassifier . from sklearn.metrics import make_scorer, accuracy_score . from sklearn.model_selection import GridSearchCV . X_train = training.drop(labels=[&quot;PassengerId&quot;, &quot;Survived&quot;], axis=1) #define training features set y_train = training[&quot;Survived&quot;] #define training label set X_test = testing.drop(&quot;PassengerId&quot;, axis=1) #define testing features set #we don&#39;t have y_test, that is what we&#39;re trying to predict with our model . X_train.head() . Pclass Sex Age SibSp Parch Fare Embarked FamSize IsAlone Title . 0 3 | 1 | -0.565736 | 1 | 0 | -0.502445 | 2 | 2 | 0 | 3 | . 1 1 | 0 | 0.663861 | 1 | 0 | 0.786845 | 0 | 2 | 0 | 4 | . 2 3 | 0 | -0.258337 | 0 | 0 | -0.488854 | 2 | 1 | 1 | 2 | . 3 1 | 0 | 0.433312 | 1 | 0 | 0.420730 | 2 | 2 | 0 | 4 | . 4 3 | 1 | 0.433312 | 0 | 0 | -0.486337 | 2 | 1 | 1 | 3 | . from sklearn.model_selection import train_test_split #to create validation data set X_training, X_valid, y_training, y_valid = train_test_split(X_train, y_train, test_size=0.2, random_state=0) #X_valid and y_valid are the validation sets . svc_clf = SVC() parameters_svc = {&quot;kernel&quot;: [&quot;rbf&quot;, &quot;linear&quot;], &quot;probability&quot;: [True, False], &quot;verbose&quot;: [True, False]} grid_svc = GridSearchCV(svc_clf, parameters_svc, scoring=make_scorer(accuracy_score)) grid_svc.fit(X_training, y_training) svc_clf = grid_svc.best_estimator_ svc_clf.fit(X_training, y_training) pred_svc = svc_clf.predict(X_valid) acc_svc = accuracy_score(y_valid, pred_svc) . [LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM][LibSVM] . print(&quot;The Score for SVC is: &quot; + str(acc_svc)) . The Score for SVC is: 0.8212290502793296 . linsvc_clf = LinearSVC() parameters_linsvc = {&quot;multi_class&quot;: [&quot;ovr&quot;, &quot;crammer_singer&quot;], &quot;fit_intercept&quot;: [True, False], &quot;max_iter&quot;: [100, 500, 1000, 1500]} grid_linsvc = GridSearchCV(linsvc_clf, parameters_linsvc, scoring=make_scorer(accuracy_score)) grid_linsvc.fit(X_training, y_training) linsvc_clf = grid_linsvc.best_estimator_ linsvc_clf.fit(X_training, y_training) pred_linsvc = linsvc_clf.predict(X_valid) acc_linsvc = accuracy_score(y_valid, pred_linsvc) print(&quot;The Score for LinearSVC is: &quot; + str(acc_linsvc)) . The Score for LinearSVC is: 0.7932960893854749 . rf_clf = RandomForestClassifier() parameters_rf = {&quot;n_estimators&quot;: [4, 5, 6, 7, 8, 9, 10, 15], &quot;criterion&quot;: [&quot;gini&quot;, &quot;entropy&quot;], &quot;max_features&quot;: [&quot;auto&quot;, &quot;sqrt&quot;, &quot;log2&quot;], &quot;max_depth&quot;: [2, 3, 5, 10], &quot;min_samples_split&quot;: [2, 3, 5, 10]} grid_rf = GridSearchCV(rf_clf, parameters_rf, scoring=make_scorer(accuracy_score)) grid_rf.fit(X_training, y_training) rf_clf = grid_rf.best_estimator_ rf_clf.fit(X_training, y_training) pred_rf = rf_clf.predict(X_valid) acc_rf = accuracy_score(y_valid, pred_rf) print(&quot;The Score for Random Forest is: &quot; + str(acc_rf)) . The Score for Random Forest is: 0.8268156424581006 . logreg_clf = LogisticRegression() parameters_logreg = {&quot;penalty&quot;: [&quot;l2&quot;], &quot;fit_intercept&quot;: [True, False], &quot;solver&quot;: [&quot;newton-cg&quot;, &quot;lbfgs&quot;, &quot;liblinear&quot;, &quot;sag&quot;, &quot;saga&quot;], &quot;max_iter&quot;: [50, 100, 200], &quot;warm_start&quot;: [True, False]} grid_logreg = GridSearchCV(logreg_clf, parameters_logreg, scoring=make_scorer(accuracy_score)) grid_logreg.fit(X_training, y_training) logreg_clf = grid_logreg.best_estimator_ logreg_clf.fit(X_training, y_training) pred_logreg = logreg_clf.predict(X_valid) acc_logreg = accuracy_score(y_valid, pred_logreg) print(&quot;The Score for Logistic Regression is: &quot; + str(acc_logreg)) . The Score for Logistic Regression is: 0.8044692737430168 . knn_clf = KNeighborsClassifier() parameters_knn = {&quot;n_neighbors&quot;: [3, 5, 10, 15], &quot;weights&quot;: [&quot;uniform&quot;, &quot;distance&quot;], &quot;algorithm&quot;: [&quot;auto&quot;, &quot;ball_tree&quot;, &quot;kd_tree&quot;], &quot;leaf_size&quot;: [20, 30, 50]} grid_knn = GridSearchCV(knn_clf, parameters_knn, scoring=make_scorer(accuracy_score)) grid_knn.fit(X_training, y_training) knn_clf = grid_knn.best_estimator_ knn_clf.fit(X_training, y_training) pred_knn = knn_clf.predict(X_valid) acc_knn = accuracy_score(y_valid, pred_knn) print(&quot;The Score for KNeighbors is: &quot; + str(acc_knn)) . The Score for KNeighbors is: 0.7653631284916201 . gnb_clf = GaussianNB() parameters_gnb = {} grid_gnb = GridSearchCV(gnb_clf, parameters_gnb, scoring=make_scorer(accuracy_score)) grid_gnb.fit(X_training, y_training) gnb_clf = grid_gnb.best_estimator_ gnb_clf.fit(X_training, y_training) pred_gnb = gnb_clf.predict(X_valid) acc_gnb = accuracy_score(y_valid, pred_gnb) print(&quot;The Score for Gaussian NB is: &quot; + str(acc_gnb)) . The Score for Gaussian NB is: 0.776536312849162 . dt_clf = DecisionTreeClassifier() parameters_dt = {&quot;criterion&quot;: [&quot;gini&quot;, &quot;entropy&quot;], &quot;splitter&quot;: [&quot;best&quot;, &quot;random&quot;], &quot;max_features&quot;: [&quot;auto&quot;, &quot;sqrt&quot;, &quot;log2&quot;]} grid_dt = GridSearchCV(dt_clf, parameters_dt, scoring=make_scorer(accuracy_score)) grid_dt.fit(X_training, y_training) dt_clf = grid_dt.best_estimator_ dt_clf.fit(X_training, y_training) pred_dt = dt_clf.predict(X_valid) acc_dt = accuracy_score(y_valid, pred_dt) print(&quot;The Score for Decision Tree is: &quot; + str(acc_dt)) . The Score for Decision Tree is: 0.7877094972067039 . model_performance = pd.DataFrame({ &quot;Model&quot;: [&quot;SVC&quot;, &quot;Linear SVC&quot;, &quot;Random Forest&quot;, &quot;Logistic Regression&quot;, &quot;K Nearest Neighbors&quot;, &quot;Gaussian Naive Bayes&quot;, &quot;Decision Tree&quot;], &quot;Accuracy&quot;: [acc_svc, acc_linsvc, acc_rf, acc_logreg, acc_knn, acc_gnb, acc_dt] }) model_performance.sort_values(by=&quot;Accuracy&quot;, ascending=False) . Model Accuracy . 2 Random Forest | 0.826816 | . 0 SVC | 0.821229 | . 3 Logistic Regression | 0.804469 | . 1 Linear SVC | 0.793296 | . 6 Decision Tree | 0.787709 | . 5 Gaussian Naive Bayes | 0.776536 | . 4 K Nearest Neighbors | 0.765363 | . svc_clf.fit(X_train, y_train) . [LibSVM] . SVC(probability=True, verbose=True) . submission_predictions = svc_clf.predict(X_test) . submission = pd.DataFrame({ &quot;PassengerId&quot;: testing[&quot;PassengerId&quot;], &quot;Survived&quot;: submission_predictions }) submission.to_csv(&quot;titanic.csv&quot;, index=False) print(submission.shape) . (418, 2) .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/20/Modelado-con-el-dataset-Titanic.html",
            "relUrl": "/2021/09/20/Modelado-con-el-dataset-Titanic.html",
            "date": " • Sep 20, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Modelado Con El Dataset Titanic Documento",
            "content": "Preparación de datos y modelado para el dataset Titanic . 1) Importar librerías y paquetes . Además de hablar de las librerías y paquetes, me pareció interesante destacar ciertos conceptos que no fueron presentados en la clase y quizás alguna posible mejora para alguna parte del código en el caso de manejar datasets más pesados y más cómputo-dependientes. . Inicialmente, se importan las librerías necesarias como numpy y pandas para cálculos matemáticos y estructuras de datos además de matplotlib y seaborn para la parte de visualización de datos y gráficas. . Luego, se importan varias funcionalidades/modelos de la librería scikit learn. Los modelos importados y una breve explicación de ellos es la siguiente. . SVC, Linear SVC son algoritmos del tipo Support vector machines, los cuales buscan definir una recta, plano o hiperplano (hablando de un SVM lineal) tal que la distancia entre esta recta y el punto más cercano de cada clase sea máxima. . Dentro de los algoritmos de árboles o ensembles, se utilizan un decisionTreeClassifier, un randomForestClassifier y XGBoost. El decisionTreeClassifier construye un único árbol y lo utiliza para hacer las predicciones. El random forest construye múltiples árboles armados utilizando bagging y luego al realizar una predicción se le da un peso al resultado de cada árbol del bosque y se decide qué predice el bosque (juntando las predicciones de cada uno y sus pesos). Por último, XGBoost utiliza una forma diferente de armar los árboles dado que son dependientes uno de otro, intentando mejorar las métricas con cada árbol nuevo. . También se utiliza la técnica de Gridsearch para tunear los hiperparámetros de los distintos algoritmos. Una mejor alternativa para un caso computacionalmente complejo sería utilizar randomsearch para ubicar los puntos de interés donde es muy probable encontrar óptimos en la cercanía y aplicar gridsearch en espacios pequeños cercanos a dichos puntos de interés. . 2) &gt; Cargar el dataset y mostrarlo . Para realizar estas dos tareas, se utilizan las funcionalidades de pandas llamadas read_csv para leer un archivo csv y cargarlo utilizando la estructura de datos llamada dataframe y head como forma de imprimir las primeras x filas (5 por defecto) del dataset de una forma prolija. . 3) &gt; Gestionar los valores faltantes . Se utiliza la función pd.isnull para identificar los valores faltantes de cada columna. Se dropean las columnas Cabin y ticket por la gran cantidad de valores faltantes. . Se observa una distribución relativamente parecida a una normal para el atributo age, pero con un leve sesgo hacia la derecha, lo que determinará la estrategia de imputación utilizada. Debido a este sesgo, elegir la mediana es una mejor alternativa que elegir la media. Si no tuviéramos este sesgo, la estrategia de imputación elegida sería la media. . Para el atributo fare, la distribución está fuertemente sesgada hacia la derecha, por lo que se elige la mediana como valor a imputar. Alternativamente, se podría elegir aplicar una transformación a los datos para que su distribución se asemeje más a una normal. 2 estrategias para esto podrían ser aplicar el logaritmo natural a los valores del atributo o alguna de las variantes de la transformación “Box and Cox” (1964) presentada en applied-predictivemodeling, presente en la bibliografía del curso. . 4) &gt; Graficar los datos . Se grafican varios atributos en relación al atributo a predecir para formar unas hipótesis iniciales sobre si algún atributo está correlacionado con la variable a predecir. Las librerías para . hacer esto son seaborn y matplotlib.pyplot. Aquí se pueden observar ratios como la proporción de mujeres que sobrevivieron o indicios como qué clase es la que presentó más proporción de personas que sobrevivieron. . 5) &gt; Feature Engineering . En la parte de feature engineering, lo primero que se hace es encodear los atributos categóricos a valores enteros. Se podría realizar mediante one hot encoding pero en este notebok, se decide no hacerlo. . Una hipótesis muy interesante provista por Samson Qian (creador del notebook en kaggle) es que el titulo de la persona puede influir en si esta sobrevivió o no. Desde mi punto de vista personal, quizás esto podría estar agregando un atributo fuertemente correlacionado con Sex. Luego de calcular la matriz de correlación, se ve que la correlación es muy baja, lo que no me parece intuitivo, dado que la gran mayoría de los ejemplos de títulos (más del 90%) son Mr, Mrs y Miss los cuales se podrían relacionar directamente con el género. . (Imagen de correlación provista debajo) . . Luego, se normalizan los datos con el standard scaler (estandarización Z). . Pasos Opcionales . Como no se requiere, no voy a comentar todos los aspectos sobre la parte de modelado, predicción y evaluación de rendimiento, pero sí los incluí en el código y me interesaría remarcar algunos puntos. . Se puede ver que los mejores resultados a primera vista, pues la única métrica que estamos mirando es accuracy (no es suficiente para tomar una decisión sobre si el modelo es bueno o no), son los de SVC y random forest, alrededor de 0.82 – 0.83, pero varía cada vez, dado que el random forest tiene un grado de aleatoriedad en su construcción. . Cabe destacar que, aunque los resultados del random forest sean los mejores para este set de testeo, el modelo tardó 60 segundos en entrenar, mientras que SVC tardó 1.2 segundos y la regresión logística 3.4s. Para conjuntos de datos más grandes o muy cambiantes para los que se necesita reentrenar el modelo constantemente, habría que ver si los pocos puntos de mejora en la accuracy justifican el costo inmensamente mayor de entrenamiento del modelo de random forest. Probablemente los tiempos de inferencia también sean mucho mayores en el random forest. . .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/20/Modelado-con-el-dataset-Titanic-Documento.html",
            "relUrl": "/2021/09/20/Modelado-con-el-dataset-Titanic-Documento.html",
            "date": " • Sep 20, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Naive Bayes   Dataset Golf",
            "content": "Naive bayes . Comparación entre utilización de atributos numéricos sin aplicar transformaciones y su conversión a atributos categóricas. . Se utiliza el dataset golf provisto por Rapidminer para este ejercicio. . Parte 1 . Conversión de atributos numéricos a categóricos (multinominales). Esto se aplica tanto para el dataset de entrenamiento como para el dataset de test. . Se genera el modelo con Naive Bayes y los resultados fueron los siguientes: . . La exactitud obtenida es de 10/14 . Parte 2 . Los atributos numéricos se tratan como numéricos. Se genera el modelo con Naive bayes y los resultados fueron los siguientes: . . La exactitud obtenida es de 9/14 . Comparación de resultados . En este caso podríamos concluir que el modelo generado con las variables categóricas tiene mejores resultados que el de variables numéricas.  . Las distribuciones no se asemejan a una distribución gaussiana. De aquí pueden derivar los peores resultados al tratar a los atributos como numéricos. . .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/18/Naive-Bayes-Dataset-Golf.html",
            "relUrl": "/2021/09/18/Naive-Bayes-Dataset-Golf.html",
            "date": " • Sep 18, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Knn   Dataset Iris",
            "content": "KNN Iris . Se crea un nuevo proceso con el dataset Iris de UCI. Luego, se grafican petal length y petal width en un gráfico bidimensional, diferenciando las diferentes especies por color. . . Claramente la especie iris-setosa es muy distinta a las otras 2 y por lo tanto un modelo construido con knn debería reconocer perfectamente a todos los ejemplos de dicha clase. Para el caso de iris versicolor e iris virginica, la separación es más difusa, y es muy probable que nuestro modelo de knn cometa errores al clasificar algunos ejemplos de ellas. . En cuanto a las tareas de acondicionamiento necesarias para este dataset y este algoritmo, se deberán normalizar todos los atributos dado que KNN trabaja con distancias. Una diferencia en escala entre los atributos podría perjudicar substancialmente la performance del modelo. . Operador Knn de rapidminer . K: Refiere a la cantidad de vecinos más cercanos que utilizará el algoritmo para hacer una predicción sobre un ejemplo no visto. . Weighted vote: La aplicación de un voto ponderado refiere a que; dentro de los k vecinos escogidos, el más cercano a un nuevo ejemplo será el que tendrá el mayor peso al aplicar la predicción y el más lejano será el que tendrá el menor peso. . Measure types: El tipo de medida que se utilizará para encontrar los vecinos más cercanos. Aquí se podrá mencionar si se tendrán atributos categóricos, numéricos ambos, etc. . Función de medida: Se podrá seleccionar un tipo de distancia tal que sea acorde con el tipo de medida que se seleccionó anteriormente. Por ejemplo para datos numéricos, se puede utilizar la distancia euclídea, mientras que para datos nominales se puede utilizar la Jaccard similarity. . Entrenamiento de modelo y resultados . K=5 . K=3 . K=1 . K=1 Distancia= Chebychev Distance . Análisis de resultados . Contrario a lo que hubiera pensado, los mejores resultados fueron obtenidos con k=1 para este Split de este dataset. Las distancias de manhattan y euclídea presentaron los mismos resultados para k = 1, mientras que la de chebychev presentó una exactitud levemente menor. . Mi hipótesis inicial para la clase iris-setosa resultó ser cierta para la mayoría de los modelos creados (menos para el modelo en el que se utiliza la distancia de chebychev). Esta clase obtuvo una precisión y un recall de 100%. .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/16/KNN-Dataset-Iris.html",
            "relUrl": "/2021/09/16/KNN-Dataset-Iris.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Árboles De Decisión   Dataset Iris Rapidminer",
            "content": "Utilización de árboles de decisión para clasificar los ejemplos del dataset Iris utilizando Rapidminer. . . . .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/15/%C3%81rboles-de-decisi%C3%B3n-Dataset-Iris-Rapidminer.html",
            "relUrl": "/2021/09/15/%C3%81rboles-de-decisi%C3%B3n-Dataset-Iris-Rapidminer.html",
            "date": " • Sep 15, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Title",
            "content": "&quot;Clasificación de diferentes especies de flores con Árboles de decisión&quot; . toc:true- branch: master | badges: true | comments: true | categories: [jupyter, DecisionTrees, DataPreparation] | image: images/some_folder/your_image.png | hide: false | search_exclude: true | metadata_key1: metadata_value1 | metadata_key2: metadata_value2 | . import pandas as pd import seaborn as sns import matplotlib.pyplot as plt %matplotlib inline . df = pd.read_csv(&quot;Iris.csv&quot;) df.head() . Id SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm Species . 0 1 | 5.1 | 3.5 | 1.4 | 0.2 | Iris-setosa | . 1 2 | 4.9 | 3.0 | 1.4 | 0.2 | Iris-setosa | . 2 3 | 4.7 | 3.2 | 1.3 | 0.2 | Iris-setosa | . 3 4 | 4.6 | 3.1 | 1.5 | 0.2 | Iris-setosa | . 4 5 | 5.0 | 3.6 | 1.4 | 0.2 | Iris-setosa | . df.drop(columns=[&quot;Id&quot;], inplace=True) df.describe(include=&quot;all&quot;) . SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm Species . count 150.000000 | 150.000000 | 150.000000 | 150.000000 | 150 | . unique NaN | NaN | NaN | NaN | 3 | . top NaN | NaN | NaN | NaN | Iris-setosa | . freq NaN | NaN | NaN | NaN | 50 | . mean 5.843333 | 3.054000 | 3.758667 | 1.198667 | NaN | . std 0.828066 | 0.433594 | 1.764420 | 0.763161 | NaN | . min 4.300000 | 2.000000 | 1.000000 | 0.100000 | NaN | . 25% 5.100000 | 2.800000 | 1.600000 | 0.300000 | NaN | . 50% 5.800000 | 3.000000 | 4.350000 | 1.300000 | NaN | . 75% 6.400000 | 3.300000 | 5.100000 | 1.800000 | NaN | . max 7.900000 | 4.400000 | 6.900000 | 2.500000 | NaN | . Visualizaci&#243;n de Datos . ax = plt.axes() ax.scatter(df[&quot;SepalLengthCm&quot;], df[&quot;SepalWidthCm&quot;]) ax.set(xlabel=&#39;Sepal Length&#39;, ylabel=&#39;Sepal Width&#39;, title=&#39;Sepal Length vs Sepal Width&#39;) . [Text(0, 0.5, &#39;Sepal Width&#39;), Text(0.5, 0, &#39;Sepal Length&#39;), Text(0.5, 1.0, &#39;Sepal Length vs Sepal Width&#39;)] . sns.set_context(&#39;notebook&#39;) ax = df.plot.hist(bins=25, alpha=0.3) ax.set_xlabel(&#39;Size (cm)&#39;) . Text(0.5, 0, &#39;Size (cm)&#39;) . sns.set_context(&#39;talk&#39;) sns.pairplot(df, hue=&#39;Species&#39;) . &lt;seaborn.axisgrid.PairGrid at 0x1cc600ec9a0&gt; . from sklearn import tree from sklearn.model_selection import train_test_split from sklearn.preprocessing import LabelEncoder clf = tree.DecisionTreeClassifier() y = df[&quot;Species&quot;] le = LabelEncoder() y_encoded = le.fit_transform(y) X = df.drop(columns=[&quot;Species&quot;]).values . train_X, test_X, train_y, test_y = train_test_split(X, y_encoded, test_size=0.3, random_state=42, shuffle=True) . clf = clf.fit(train_X, train_y) . plt.figure(dpi=50, figsize=(50,50)) tree.plot_tree(clf) . [Text(968.75, 1730.2083333333333, &#39;X[3] &lt;= 0.8 ngini = 0.664 nsamples = 105 nvalue = [31, 37, 37]&#39;), Text(819.7115384615386, 1415.625, &#39;gini = 0.0 nsamples = 31 nvalue = [31, 0, 0]&#39;), Text(1117.7884615384617, 1415.625, &#39;X[3] &lt;= 1.75 ngini = 0.5 nsamples = 74 nvalue = [0, 37, 37]&#39;), Text(596.1538461538462, 1101.0416666666667, &#39;X[2] &lt;= 4.95 ngini = 0.214 nsamples = 41 nvalue = [0, 36, 5]&#39;), Text(298.0769230769231, 786.4583333333335, &#39;X[3] &lt;= 1.6 ngini = 0.056 nsamples = 35 nvalue = [0, 34, 1]&#39;), Text(149.03846153846155, 471.875, &#39;gini = 0.0 nsamples = 34 nvalue = [0, 34, 0]&#39;), Text(447.11538461538464, 471.875, &#39;gini = 0.0 nsamples = 1 nvalue = [0, 0, 1]&#39;), Text(894.2307692307693, 786.4583333333335, &#39;X[3] &lt;= 1.55 ngini = 0.444 nsamples = 6 nvalue = [0, 2, 4]&#39;), Text(745.1923076923077, 471.875, &#39;gini = 0.0 nsamples = 3 nvalue = [0, 0, 3]&#39;), Text(1043.269230769231, 471.875, &#39;X[2] &lt;= 5.45 ngini = 0.444 nsamples = 3 nvalue = [0, 2, 1]&#39;), Text(894.2307692307693, 157.29166666666674, &#39;gini = 0.0 nsamples = 2 nvalue = [0, 2, 0]&#39;), Text(1192.3076923076924, 157.29166666666674, &#39;gini = 0.0 nsamples = 1 nvalue = [0, 0, 1]&#39;), Text(1639.4230769230771, 1101.0416666666667, &#39;X[2] &lt;= 4.85 ngini = 0.059 nsamples = 33 nvalue = [0, 1, 32]&#39;), Text(1490.3846153846155, 786.4583333333335, &#39;X[1] &lt;= 3.1 ngini = 0.444 nsamples = 3 nvalue = [0, 1, 2]&#39;), Text(1341.3461538461538, 471.875, &#39;gini = 0.0 nsamples = 2 nvalue = [0, 0, 2]&#39;), Text(1639.4230769230771, 471.875, &#39;gini = 0.0 nsamples = 1 nvalue = [0, 1, 0]&#39;), Text(1788.4615384615386, 786.4583333333335, &#39;gini = 0.0 nsamples = 30 nvalue = [0, 0, 30]&#39;)] . y_pred = clf.predict(test_X) print(&quot;Predicted vs Expected&quot;) print(y_pred) print(test_y) . Predicted vs Expected [1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1 0 0 0 2 1 1 0 0] [1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1 0 0 0 2 1 1 0 0] . from sklearn.metrics import confusion_matrix test_y_inv = le.inverse_transform(test_y) y_pred_inv = le.inverse_transform(y_pred) categories = set(df[&quot;Species&quot;]) cf_matrix = confusion_matrix(test_y_inv, y_pred_inv) sns.heatmap(cf_matrix, annot=True,cmap=&#39;Blues&#39;, xticklabels=categories, yticklabels=categories) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1cc6168b100&gt; .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/15/%C3%81rboles-de-decisi%C3%B3n-Dataset-Iris-Notebook.html",
            "relUrl": "/2021/09/15/%C3%81rboles-de-decisi%C3%B3n-Dataset-Iris-Notebook.html",
            "date": " • Sep 15, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Svm",
            "content": "Máquinas de soporte vectorial . Se generó un dataset de ejemplo para mostrar un caso en el que las máquinas de soporte vectorial demuestran su potencial. El dataset utilizado es SVM-Anillos.csv. . Al visualizar los datos, las clases parecerían estar separadas mediante un anillo. Por esta razón podríamos plantearnos las siguientes hipótesis: . 1) Utilizar un kernel lineal es una mala opción, pues no existe una recta que haga una buena separación de los 2 conjuntos. . 2) Probablemente un kernel radial o uno polinómico de grado par obtenga buenos resultados . . Flujo de Rapidminer . . Cross validation . . Resultados: . Kernel lineal . . Kernel radial . . Kernel Polinómico Par e Impar . . Observamos el mismo comportamiento que con el kernel radial para un kernel polinómico de grado 2. Modificando el grado del kernel a valores pares, se puede ver una accuracy de 100%, mientras que utilizando un grado impar, los resultados se acercan más al 70-75% utilizando 10-fold-CV. . Cambio de la constante C . No se observan cambios notorios al modificar la constante c para este dataset, dado que los datos están perfectamente separados. . Conclusiones . Como conclusión, se probaron ambas hipótesis planteadas mediante el entrenamiento de diferentes máquinas de soporte vectorial con la utilización de distintos kernels. .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/15/SVM.html",
            "relUrl": "/2021/09/15/SVM.html",
            "date": " • Sep 15, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "Title",
            "content": "&quot;Prediciendo deportes jugados con algoritmos lineales&quot; . toc:true- branch: master | badges: true | comments: true | categories: [jupyter, LinearDiscriminantAnalysis] | image: images/some_folder/your_image.png | hide: false | search_exclude: true | metadata_key1: metadata_value1 | metadata_key2: metadata_value2 | . import matplotlib import matplotlib.pyplot as plt import pandas as pd from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.metrics import confusion_matrix, classification_report from sklearn.model_selection import train_test_split from sklearn.preprocessing import LabelEncoder import seaborn as sns . input_file = &quot;sports_Training.csv&quot; df = pd.read_csv(input_file, header=0) df.head() . Edad Fuerza Velocidad Lesiones Vision Resistencia Agilidad CapacidadDecision DeportePrimario . 0 15.1 | 3 | 2 | 1 | 2 | 3 | 29 | 4 | Futbol | . 1 15.4 | 3 | 2 | 0 | 3 | 5 | 18 | 8 | Rugby | . 2 13.6 | 5 | 5 | 0 | 2 | 5 | 27 | 28 | Voleibol | . 3 18.8 | 5 | 1 | 1 | 1 | 3 | 48 | 36 | Voleibol | . 4 16.1 | 3 | 1 | 0 | 3 | 3 | 38 | 29 | Futbol | . data = df[(df[&#39;CapacidadDecision&#39;] &gt;= 3) &amp; (df[&#39;CapacidadDecision&#39;] &lt;= 100)] data.head() . Edad Fuerza Velocidad Lesiones Vision Resistencia Agilidad CapacidadDecision DeportePrimario . 0 15.1 | 3 | 2 | 1 | 2 | 3 | 29 | 4 | Futbol | . 1 15.4 | 3 | 2 | 0 | 3 | 5 | 18 | 8 | Rugby | . 2 13.6 | 5 | 5 | 0 | 2 | 5 | 27 | 28 | Voleibol | . 3 18.8 | 5 | 1 | 1 | 1 | 3 | 48 | 36 | Voleibol | . 4 16.1 | 3 | 1 | 0 | 3 | 3 | 38 | 29 | Futbol | . data.describe() . Edad Fuerza Velocidad Lesiones Vision Resistencia Agilidad CapacidadDecision . count 482.000000 | 482.000000 | 482.000000 | 482.000000 | 482.000000 | 482.000000 | 482.000000 | 482.000000 | . mean 15.954564 | 3.500000 | 1.983402 | 0.639004 | 1.692946 | 3.856846 | 33.680498 | 29.157676 | . std 1.817320 | 1.460854 | 1.505269 | 0.480788 | 1.134010 | 1.331782 | 12.523973 | 19.477265 | . min 13.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 13.000000 | 3.000000 | . 25% 14.300000 | 3.000000 | 1.000000 | 0.000000 | 1.000000 | 3.000000 | 23.000000 | 11.000000 | . 50% 15.900000 | 4.000000 | 1.000000 | 1.000000 | 2.000000 | 5.000000 | 31.500000 | 29.000000 | . 75% 17.600000 | 4.000000 | 2.000000 | 1.000000 | 3.000000 | 5.000000 | 42.750000 | 40.000000 | . max 19.000000 | 7.000000 | 6.000000 | 1.000000 | 3.000000 | 6.000000 | 80.000000 | 100.000000 | . data.dtypes . Edad float64 Fuerza int64 Velocidad int64 Lesiones int64 Vision int64 Resistencia int64 Agilidad int64 CapacidadDecision int64 DeportePrimario object dtype: object . y = data[&quot;DeportePrimario&quot;] le = LabelEncoder() y_encoded = le.fit_transform(y) . X = data.drop(columns=[&#39;DeportePrimario&#39;]).values type(X) . numpy.ndarray . type(y_encoded) . numpy.ndarray . train_X, test_X, train_y, test_y = train_test_split(X, y_encoded, test_size=0.25, random_state=41, shuffle=True) . lda = LinearDiscriminantAnalysis() lda = lda.fit(train_X, train_y) . type(test_X) . numpy.ndarray . y_pred = lda.predict(test_X) print(&quot;Predicted vs Expected&quot;) print(y_pred) print(test_y) . Predicted vs Expected [3 1 2 1 1 0 0 0 1 2 2 2 1 3 3 0 2 3 2 3 3 2 1 1 2 3 0 0 1 3 3 1 1 2 2 2 2 1 1 1 1 2 3 3 1 1 3 1 1 1 1 2 1 1 1 1 2 3 3 1 2 1 0 1 2 1 1 2 1 1 3 2 2 2 2 1 0 1 2 1 1 3 1 1 1 1 1 2 1 2 1 2 0 3 1 1 1 2 2 3 2 0 2 1 1 1 1 3 1 0 1 1 3 1 2 3 1 1 3 1 3] [1 2 2 1 3 3 2 2 1 1 2 2 1 1 3 2 2 0 2 3 1 2 2 0 2 0 1 0 1 3 0 0 2 1 0 1 2 1 3 3 3 2 0 3 1 1 1 3 3 1 1 3 3 1 3 1 0 2 3 2 1 1 0 0 3 1 1 3 2 0 0 1 1 2 0 3 1 1 0 0 2 0 1 3 3 1 2 0 3 2 2 2 0 0 2 3 1 1 2 2 2 0 1 3 2 1 1 1 1 3 2 1 3 0 2 1 1 2 3 1 3] . print(classification_report(test_y, y_pred, digits=3)) . precision recall f1-score support 0 0.364 0.182 0.242 22 1 0.429 0.600 0.500 40 2 0.484 0.469 0.476 32 3 0.348 0.296 0.320 27 accuracy 0.421 121 macro avg 0.406 0.387 0.385 121 weighted avg 0.413 0.421 0.407 121 . print(confusion_matrix(test_y, y_pred)) . [[ 4 6 5 7] [ 2 24 8 6] [ 3 12 15 2] [ 2 14 3 8]] . test_y_inv = le.inverse_transform(test_y) y_pred_inv = le.inverse_transform(y_pred) categories = [&#39;Futbol&#39;, &#39;Rugby&#39;, &quot;Basketball&quot;,&#39;Voleibol&#39;] cf_matrix = confusion_matrix(test_y_inv, y_pred_inv) sns.heatmap(cf_matrix, annot=True,cmap=&#39;Blues&#39;, xticklabels=categories, yticklabels=categories) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2022c31dd60&gt; . Predicciones en set no visto: Validaci&#243;n . validation_df = pd.read_csv(&quot;sports_Scoring.csv&quot;) validation_df.head() . Edad Fuerza Velocidad Lesiones Vision Resistencia Agilidad CapacidadDecision . 0 18.5 | 5 | 1 | 1 | 0 | 5 | 33 | 61 | . 1 13.3 | 1 | 2 | 1 | 3 | 5 | 18 | 59 | . 2 13.4 | 2 | 1 | 0 | 2 | 5 | 40 | 11 | . 3 13.6 | 4 | 1 | 0 | 0 | 5 | 28 | 0 | . 4 16.3 | 3 | 1 | 0 | 2 | 5 | 32 | 35 | . validation_df = validation_df[(validation_df[&#39;CapacidadDecision&#39;] &gt;= 3) &amp; (validation_df[&#39;CapacidadDecision&#39;] &lt;= 100)] validation_df.describe() . Edad Fuerza Velocidad Lesiones Vision Resistencia Agilidad CapacidadDecision . count 1767.000000 | 1767.000000 | 1767.000000 | 1767.000000 | 1767.000000 | 1767.000000 | 1767.000000 | 1767.000000 | . mean 15.982513 | 3.567063 | 1.987550 | 0.664969 | 1.599887 | 3.736276 | 34.013016 | 29.946237 | . std 1.729906 | 1.479915 | 1.551992 | 0.472135 | 1.188402 | 1.366378 | 12.299599 | 21.116807 | . min 13.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 13.000000 | 3.000000 | . 25% 14.500000 | 3.000000 | 1.000000 | 0.000000 | 0.000000 | 3.000000 | 24.000000 | 11.000000 | . 50% 16.000000 | 4.000000 | 1.000000 | 1.000000 | 2.000000 | 3.000000 | 32.000000 | 29.000000 | . 75% 17.400000 | 4.000000 | 2.000000 | 1.000000 | 3.000000 | 5.000000 | 43.000000 | 44.000000 | . max 19.000000 | 7.000000 | 6.000000 | 1.000000 | 3.000000 | 6.000000 | 80.000000 | 100.000000 | . validation_df.columns . Index([&#39;Edad&#39;, &#39;Fuerza&#39;, &#39;Velocidad&#39;, &#39;Lesiones&#39;, &#39;Vision&#39;, &#39;Resistencia&#39;, &#39;Agilidad&#39;, &#39;CapacidadDecision&#39;], dtype=&#39;object&#39;) . y_pred = lda.predict(validation_df.to_numpy()) . print(y_pred) . [0 2 1 ... 1 0 1] .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/12/Algoritmos-Lineales-para-clasificaci%C3%B3n-Dataset-Sports.html",
            "relUrl": "/2021/09/12/Algoritmos-Lineales-para-clasificaci%C3%B3n-Dataset-Sports.html",
            "date": " • Sep 12, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "Title",
            "content": "&quot;Preparación de datos para el dataset Wine&quot; . toc:true- branch: master | badges: true | comments: true | categories: [jupyter, Normalization, DataPreparation] | image: images/some_folder/your_image.png | hide: false | search_exclude: true | metadata_key1: metadata_value1 | metadata_key2: metadata_value2 | . Se importa el dataset y se imprimen las 10 primeras filas . import os, types import pandas as pd from botocore.client import Config import ibm_boto3 def __iter__(self): return 0 # @hidden_cell # The following code accesses a file in your IBM Cloud Object Storage. It includes your credentials. # You might want to remove those credentials before you share the notebook. if os.environ.get(&#39;RUNTIME_ENV_LOCATION_TYPE&#39;) == &#39;external&#39;: endpoint_1d798346e565465c95da182cbfe9fccb = &#39;https://s3.us.cloud-object-storage.appdomain.cloud&#39; else: endpoint_1d798346e565465c95da182cbfe9fccb = &#39;https://s3.private.us.cloud-object-storage.appdomain.cloud&#39; client_1d798346e565465c95da182cbfe9fccb = ibm_boto3.client(service_name=&#39;s3&#39;, ibm_api_key_id=&#39;MiApiKey&#39;, ibm_auth_endpoint=&quot;https://iam.cloud.ibm.com/oidc/token&quot;, config=Config(signature_version=&#39;oauth&#39;), endpoint_url=endpoint_1d798346e565465c95da182cbfe9fccb) body = client_1d798346e565465c95da182cbfe9fccb.get_object(Bucket=&#39;facultadia-donotdelete-pr-qcdq5gqyjj8z2s&#39;,Key=&#39;wine.csv&#39;)[&#39;Body&#39;] # add missing __iter__ method, so pandas accepts body as file-like object if not hasattr(body, &quot;__iter__&quot;): body.__iter__ = types.MethodType( __iter__, body ) df = pd.read_csv(body) df.head(10) . Class Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline . 0 1 | 14.23 | 1.71 | 2.43 | 15.6 | 127 | 2.80 | 3.06 | 0.28 | 2.29 | 5.64 | 1.04 | 3.92 | 1065 | . 1 1 | 13.20 | 1.78 | 2.14 | 11.2 | 100 | 2.65 | 2.76 | 0.26 | 1.28 | 4.38 | 1.05 | 3.40 | 1050 | . 2 1 | 13.16 | 2.36 | 2.67 | 18.6 | 101 | 2.80 | 3.24 | 0.30 | 2.81 | 5.68 | 1.03 | 3.17 | 1185 | . 3 1 | 14.37 | 1.95 | 2.50 | 16.8 | 113 | 3.85 | 3.49 | 0.24 | 2.18 | 7.80 | 0.86 | 3.45 | 1480 | . 4 1 | 13.24 | 2.59 | 2.87 | 21.0 | 118 | 2.80 | 2.69 | 0.39 | 1.82 | 4.32 | 1.04 | 2.93 | 735 | . 5 1 | 14.20 | 1.76 | 2.45 | 15.2 | 112 | 3.27 | 3.39 | 0.34 | 1.97 | 6.75 | 1.05 | 2.85 | 1450 | . 6 1 | 14.39 | 1.87 | 2.45 | 14.6 | 96 | 2.50 | 2.52 | 0.30 | 1.98 | 5.25 | 1.02 | 3.58 | 1290 | . 7 1 | 14.06 | 2.15 | 2.61 | 17.6 | 121 | 2.60 | 2.51 | 0.31 | 1.25 | 5.05 | 1.06 | 3.58 | 1295 | . 8 1 | 14.83 | 1.64 | 2.17 | 14.0 | 97 | 2.80 | 2.98 | 0.29 | 1.98 | 5.20 | 1.08 | 2.85 | 1045 | . 9 1 | 13.86 | 1.35 | 2.27 | 16.0 | 98 | 2.98 | 3.15 | 0.22 | 1.85 | 7.22 | 1.01 | 3.55 | 1045 | . #3, 4 5 y 6 con una única línea de código # Mediante el describe, podemos ver que todos los atributos son numéricos. De lo contrario, podríamos utilizar el código comentado anteriormente para convertir el tipo a numérico. df.describe(include=&#39;all&#39;) . Class Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline . count 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | 178.000000 | . mean 1.938202 | 13.000618 | 2.336348 | 2.366517 | 19.494944 | 99.741573 | 2.295112 | 2.029270 | 0.361854 | 1.590899 | 5.058090 | 0.957449 | 2.611685 | 746.893258 | . std 0.775035 | 0.811827 | 1.117146 | 0.274344 | 3.339564 | 14.282484 | 0.625851 | 0.998859 | 0.124453 | 0.572359 | 2.318286 | 0.228572 | 0.709990 | 314.907474 | . min 1.000000 | 11.030000 | 0.740000 | 1.360000 | 10.600000 | 70.000000 | 0.980000 | 0.340000 | 0.130000 | 0.410000 | 1.280000 | 0.480000 | 1.270000 | 278.000000 | . 25% 1.000000 | 12.362500 | 1.602500 | 2.210000 | 17.200000 | 88.000000 | 1.742500 | 1.205000 | 0.270000 | 1.250000 | 3.220000 | 0.782500 | 1.937500 | 500.500000 | . 50% 2.000000 | 13.050000 | 1.865000 | 2.360000 | 19.500000 | 98.000000 | 2.355000 | 2.135000 | 0.340000 | 1.555000 | 4.690000 | 0.965000 | 2.780000 | 673.500000 | . 75% 3.000000 | 13.677500 | 3.082500 | 2.557500 | 21.500000 | 107.000000 | 2.800000 | 2.875000 | 0.437500 | 1.950000 | 6.200000 | 1.120000 | 3.170000 | 985.000000 | . max 3.000000 | 14.830000 | 5.800000 | 3.230000 | 30.000000 | 162.000000 | 3.880000 | 5.080000 | 0.660000 | 3.580000 | 13.000000 | 1.710000 | 4.000000 | 1680.000000 | . Normalizar MinMax y estandarizar . df_class = df[&quot;Class&quot;] df = df.drop(columns=[&quot;Class&quot;]) df_min_max = df.copy() df_normalized = df.copy() df_normalized.head() . Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline . 0 14.23 | 1.71 | 2.43 | 15.6 | 127 | 2.80 | 3.06 | 0.28 | 2.29 | 5.64 | 1.04 | 3.92 | 1065 | . 1 13.20 | 1.78 | 2.14 | 11.2 | 100 | 2.65 | 2.76 | 0.26 | 1.28 | 4.38 | 1.05 | 3.40 | 1050 | . 2 13.16 | 2.36 | 2.67 | 18.6 | 101 | 2.80 | 3.24 | 0.30 | 2.81 | 5.68 | 1.03 | 3.17 | 1185 | . 3 14.37 | 1.95 | 2.50 | 16.8 | 113 | 3.85 | 3.49 | 0.24 | 2.18 | 7.80 | 0.86 | 3.45 | 1480 | . 4 13.24 | 2.59 | 2.87 | 21.0 | 118 | 2.80 | 2.69 | 0.39 | 1.82 | 4.32 | 1.04 | 2.93 | 735 | . df_normalized =(df_normalized-df_normalized.mean())/df_normalized.std() df_normalized[&quot;Class&quot;] = df_class df_normalized.head() . Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline Class . 0 1.514341 | -0.560668 | 0.231400 | -1.166303 | 1.908522 | 0.806722 | 1.031908 | -0.657708 | 1.221438 | 0.251009 | 0.361158 | 1.842721 | 1.010159 | 1 | . 1 0.245597 | -0.498009 | -0.825667 | -2.483841 | 0.018094 | 0.567048 | 0.731565 | -0.818411 | -0.543189 | -0.292496 | 0.404908 | 1.110317 | 0.962526 | 1 | . 2 0.196325 | 0.021172 | 1.106214 | -0.267982 | 0.088110 | 0.806722 | 1.212114 | -0.497005 | 2.129959 | 0.268263 | 0.317409 | 0.786369 | 1.391224 | 1 | . 3 1.686791 | -0.345835 | 0.486554 | -0.806975 | 0.928300 | 2.484437 | 1.462399 | -0.979113 | 1.029251 | 1.182732 | -0.426341 | 1.180741 | 2.328007 | 1 | . 4 0.294868 | 0.227053 | 1.835226 | 0.450674 | 1.278379 | 0.806722 | 0.661485 | 0.226158 | 0.400275 | -0.318377 | 0.361158 | 0.448336 | -0.037767 | 1 | . df_min_max =(df_min_max-df_min_max.min())/(df_min_max.max()-df_min_max.min()) df_min_max[&quot;Class&quot;] = df_class df_min_max.head() . Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline Class . 0 0.842105 | 0.191700 | 0.572193 | 0.257732 | 0.619565 | 0.627586 | 0.573840 | 0.283019 | 0.593060 | 0.372014 | 0.455285 | 0.970696 | 0.561341 | 1 | . 1 0.571053 | 0.205534 | 0.417112 | 0.030928 | 0.326087 | 0.575862 | 0.510549 | 0.245283 | 0.274448 | 0.264505 | 0.463415 | 0.780220 | 0.550642 | 1 | . 2 0.560526 | 0.320158 | 0.700535 | 0.412371 | 0.336957 | 0.627586 | 0.611814 | 0.320755 | 0.757098 | 0.375427 | 0.447154 | 0.695971 | 0.646933 | 1 | . 3 0.878947 | 0.239130 | 0.609626 | 0.319588 | 0.467391 | 0.989655 | 0.664557 | 0.207547 | 0.558360 | 0.556314 | 0.308943 | 0.798535 | 0.857347 | 1 | . 4 0.581579 | 0.365613 | 0.807487 | 0.536082 | 0.521739 | 0.627586 | 0.495781 | 0.490566 | 0.444795 | 0.259386 | 0.455285 | 0.608059 | 0.325963 | 1 | . from sklearn.model_selection import train_test_split # 9 Creación de train y test df_normalized_y = df_normalized[&quot;Class&quot;] df_normalized_x = df_normalized.drop(columns=[&quot;Class&quot;]) #Realizo la division con el dataset normalizado con transformación z, pero se podría hacer análogamente para el minmax. Se aplica un shuffle al dataset antes de realizar el split #con la seed 42 x_train, x_test, y_train, y_test = train_test_split( df_normalized_x, df_normalized_y, test_size=0.10, random_state=42 ) . train = x_train.join(y_train) train.head() . Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline Class . 9 1.058578 | -0.882918 | -0.351810 | -1.046527 | -0.121938 | 1.094330 | 1.122011 | -1.139816 | 0.452690 | 0.932547 | 0.229909 | 1.321588 | 0.946649 | 1 | . 114 -1.134008 | -0.847112 | 0.486554 | 0.899835 | -1.102159 | 0.423244 | 0.261028 | 0.547563 | -0.962506 | -0.930899 | -0.120091 | 0.814539 | -1.149205 | 2 | . 18 1.465069 | -0.668085 | 0.413653 | -0.896807 | 0.578221 | 1.605634 | 1.902902 | -0.336302 | 0.470162 | 1.570950 | 1.192408 | 0.293405 | 2.963114 | 1 | . 66 0.134736 | -1.187265 | -2.429493 | -1.345967 | -1.522254 | 1.094330 | 1.152045 | -0.818411 | 1.203967 | 0.104349 | 0.711158 | 0.800454 | -0.777667 | 2 | . 60 -0.826061 | -1.106702 | -0.315359 | -1.046527 | 0.088110 | -0.391646 | -0.940343 | 2.154591 | -2.063214 | -0.771298 | 1.279908 | -1.326335 | -0.212422 | 2 | . test = x_test.join(y_test) test.head() . Alcohol Malic acid Ash Alcalinity of ash Magnesium Total phenols Flavanoids Nonflavanoid phenols Proanthocyanins Color intensity Hue OD280/OD315 of diluted wines Proline Class . 19 0.787585 | 0.683574 | 0.705257 | -1.286079 | 1.138347 | 0.646939 | 1.001874 | -1.541573 | 0.120730 | 0.018078 | 0.011159 | 1.053978 | 0.311541 | 1 | . 45 1.489705 | 1.525003 | 0.267850 | -0.178150 | 0.788268 | 0.886613 | 0.621440 | -0.497005 | -0.595603 | 0.078468 | -0.382591 | 1.011724 | 1.057792 | 1 | . 140 -0.086987 | 0.423984 | 1.215566 | 0.450674 | -0.261969 | -1.206537 | -1.531017 | 1.351077 | -1.469181 | -0.197599 | -0.820091 | -0.424915 | -0.466465 | 3 | . 30 0.898446 | -0.748647 | 1.215566 | 0.899835 | 0.088110 | 1.126287 | 1.222125 | -0.577356 | 1.378682 | 0.276890 | 1.017408 | 0.138473 | 1.708777 | 1 | . 67 -0.776789 | -1.044043 | -1.627580 | 0.031458 | -1.522254 | -0.295777 | -0.029303 | -0.738059 | -0.962506 | -0.163090 | 0.711158 | 1.222995 | -0.752263 | 2 | .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/10/Preparaci%C3%B3n-de-datos-Dataset-Wine.html",
            "relUrl": "/2021/09/10/Preparaci%C3%B3n-de-datos-Dataset-Wine.html",
            "date": " • Sep 10, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "Normalización Y Detección De Outliers",
            "content": "Rapid Miner outlier detection and normalization tutorial. . Se aplica normalización para luego aplicar el cálculo de las distancias para detectar a los outliers. Siempre se debe normalizar previo al cálculo de los outliers por el hecho de que los diferentes atributos suelen no tener la misma unidad o escala. Para la normalización se utiliza la transformación z. . El operador detect outliers detectará los 10 ejemplos que se alejen más del resto. En el flujo, luego colocamos un filter para remover los 10 outliers antes mencionados. . Ejercicio 2 . El dataset posee 13 atributos sin incluir a la variable objetivo. Estos describen distintos elementos de la composición de vinos para luego poder clasificarlos. . La variable objetivo posee tres valores posibles. Estos valores representan a 3 diferentes variantes de viñedos (las plantas de las que se genera el vino son diferentes genéticamente entre sí). . La variable objetivo está relativamente balanceada, no hay una clase que presente un numero muy bajo de ejemplos, por lo que argumentaría que no habría que aplicar ningún tipo de sampling. . Para algunos atributos, la distribución parece ser normal (ash, alcalinity of ash, proanthocyanins), mientras que algunas otras parecen tener un sesgo hacia la derecha (por ejemplo malic acid y proline), pero no es muy grave tampoco. . Creación del modelo con naive bayes. . Al visualizar objetivamente la matriz de confusión, los resultados no variaron al aplicar la normalización. Con ambos tipos de normalización (z score y min-max), los resultados fueron los mismos. . Flujo de rapidminer: . El para los Split data, se utilizó la misma seed y la misma proporción (70/30) para que los conjuntos de entrenamiento y testeo sean los mismos para ambas pruebas, con la diferencia que uno estará normalizado y otro no. . . Matriz sin normalizado . . Matriz con normalizado . . Conclusiones . El normalizado no afecta los resultados para este caso en particular. Esto se debe al algoritmo que utilizamos principalmente. .",
            "url": "https://josevilaseca.github.io/Portafolio-ML/2021/09/10/Normalizaci%C3%B3n-y-detecci%C3%B3n-de-outliers.html",
            "relUrl": "/2021/09/10/Normalizaci%C3%B3n-y-detecci%C3%B3n-de-outliers.html",
            "date": " • Sep 10, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://josevilaseca.github.io/Portafolio-ML/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Actualmente soy un estudiante de Ingeniería en Informática y trabajo como científico de datos y desarrollador de aplicaciones desde el año 2020. El propósito de este portafolio es exponer algunos proyectos realizados en relación a Machine Learning. .",
          "url": "https://josevilaseca.github.io/Portafolio-ML/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://josevilaseca.github.io/Portafolio-ML/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}